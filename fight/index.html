<!DOCTYPE html>
<html>
<head>
    <title>Battle Arena</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; }
        canvas { display: block; }

        /* LOADING SCREEN OVERLAY */
        #loadingScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: white;
            display: flex; flex-direction: column; 
            align-items: center; justify-content: center;
            z-index: 999; transition: opacity 0.5s;
        }
        h1 { font-size: 50px; color: #ff0055; margin: 0; }
        p { color: #aaa; margin-top: 10px; font-size: 18px; }

        /* HUD */
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; }
        .weapon-help { position: absolute; bottom: 20px; left: 20px; color: #888; font-size: 14px; }
    </style>
</head>
<body>

    <div id="loadingScreen">
        <h1>CONNECTING...</h1>
        <p>Please wait while we match you...</p>
    </div>

    <div id="ui">
        <h2 id="score">Kills: 0</h2>
        <div style="border: 2px solid white; width: 200px; height: 15px; background: #333;">
            <div id="hpBar" style="width: 100%; height: 100%; background: #0f0; transition: width 0.2s;"></div>
        </div>
    </div>
    <div class="weapon-help">Press <b>1</b> for Rifle, <b>2</b> for Shotgun, <b>3</b> for Axe</div>

    <canvas id="gameCanvas"></canvas>

    <script src="https://8o2lymxge7.onrender.com"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- YOUR SERVER URL ---
        const socket = io('https://8o2lymxge7.onrender.com');

        // Full Screen
        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        window.onresize = resize;
        resize();

        let myId = null;
        let players = {};
        
        // --- INPUTS ---
        const keys = {};
        let mouse = { x: 0, y: 0, angle: 0 };
        
        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true; 
            
            // WEAPON SWITCHING (1, 2, 3)
            if(e.key === '1') socket.emit('switchWeapon', 'rifle');
            if(e.key === '2') socket.emit('switchWeapon', 'shotgun');
            if(e.key === '3') socket.emit('switchWeapon', 'axe');
        });
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX; 
            mouse.y = e.clientY;
            // Calculate angle from center of screen (where player is) to mouse
            mouse.angle = Math.atan2(e.clientY - canvas.height/2, e.clientX - canvas.width/2);
        });

        window.addEventListener('mousedown', () => socket.emit('attack'));

        // --- PHYSICS VARS ---
        let x = 100, y = 100, vx = 0, vy = 0;
        let grounded = false;
        let camX = 0, camY = 0;

        // --- NETWORK EVENTS ---
        
        // 1. On Connect: Remove Loading Screen
        socket.on('connect', () => {
            myId = socket.id;
            console.log("Connected!");
            // Fade out loading screen
            const loadScr = document.getElementById('loadingScreen');
            loadScr.style.opacity = '0';
            setTimeout(() => loadScr.style.display = 'none', 500);
        });

        socket.on('updatePlayers', (p) => { players = p; });
        
        socket.on('updateHealth', (pList) => {
            players = pList;
            if(players[myId]) {
                document.getElementById('hpBar').style.width = players[myId].health + "%";
                document.getElementById('score').innerText = "Kills: " + players[myId].score;
                
                // If I died and respawned, reset my position locally
                if(players[myId].health === 100 && players[myId].score === players[myId].score) { 
                   // This is a lazy way to detect respawn, but it works for now
                   // Ideally server sends a specific "respawn" event
                }
            }
        });

        // Attack Effects
        let fx = [];
        socket.on('attackAnim', (data) => {
            if(players[data.id]) {
                const p = players[data.id];
                // Use local position for me, server position for others
                const originX = (data.id === myId) ? x : p.x;
                const originY = (data.id === myId) ? y : p.y;
                
                fx.push({ 
                    x: originX, y: originY, 
                    angle: data.angle, 
                    weapon: data.weapon, 
                    timer: 5 
                });
            }
        });

        // --- GAME LOOP ---
        function update() {
            // Physics
            vx = 0;
            if (keys['a']) vx = -6;
            if (keys['d']) vx = 6;
            if ((keys['w'] || keys[' ']) && grounded) { vy = -15; grounded = false; }

            vy += 0.8; // Gravity
            x += vx;
            y += vy;

            // Floor Collision (Simple)
            if (y > 600) { y = 600; vy = 0; grounded = true; }
            
            // Send Data
            if (myId) {
                socket.emit('playerMovement', { x: x, y: y, angle: mouse.angle });
            }

            // Camera Follows Player
            camX = x - canvas.width/2;
            camY = y - canvas.height/2;
        }

        function draw() {
            update();

            // Clear Background
            ctx.fillStyle = "#222";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(-camX, -camY);

            // Draw Floor
            ctx.fillStyle = "#555";
            ctx.fillRect(-1000, 650, 4000, 100);

            // Draw Players
            for (let id in players) {
                const p = players[id];
                const isMe = (id === myId);
                
                // Interpolation for others, direct logic for me
                const drawX = isMe ? x : p.x;
                const drawY = isMe ? y : p.y;
                const drawAng = isMe ? mouse.angle : p.angle;

                // Player Box
                ctx.fillStyle = p.color;
                ctx.fillRect(drawX - 25, drawY - 25, 50, 50);

                // WEAPON DRAWING
                ctx.save();
                ctx.translate(drawX, drawY);
                ctx.rotate(drawAng);
                
                if (p.weapon === 'rifle') {
                    ctx.fillStyle = "#ccc"; // Grey Gun
                    ctx.fillRect(20, -5, 40, 10);
                } else if (p.weapon === 'shotgun') {
                    ctx.fillStyle = "#555"; // Dark fat gun
                    ctx.fillRect(20, -8, 25, 16);
                } else if (p.weapon === 'axe') {
                    ctx.fillStyle = "#8b4513"; // Brown handle
                    ctx.fillRect(10, -5, 30, 10);
                    ctx.fillStyle = "silver"; // Blade
                    ctx.fillRect(35, -20, 10, 40);
                }
                
                ctx.restore();

                // Health Bar above head
                if (!isMe) {
                    ctx.fillStyle = "red";
                    ctx.fillRect(drawX - 25, drawY - 40, 50, 5);
                    ctx.fillStyle = "#0f0";
                    ctx.fillRect(drawX - 25, drawY - 40, 50 * (p.health / 100), 5);
                }
            }

            // Draw FX (Bullets/Swings)
            ctx.lineWidth = 3;
            for(let i=0; i<fx.length; i++) {
                let f = fx[i];
                ctx.strokeStyle = "yellow";
                if(f.weapon === 'axe') ctx.strokeStyle = "white";

                ctx.beginPath();
                ctx.moveTo(f.x, f.y);
                
                let range = 800;
                if(f.weapon === 'shotgun') range = 300;
                if(f.weapon === 'axe') range = 60;

                ctx.lineTo(f.x + Math.cos(f.angle) * range, f.y + Math.sin(f.angle) * range);
                ctx.stroke();
                f.timer--;
            }
            fx = fx.filter(f => f.timer > 0);

            ctx.restore();
            requestAnimationFrame(draw);
        }

        draw();
    </script>
</body>
</html>
