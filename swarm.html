<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Swarm</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; color: white; font-family: 'Courier New', Courier, monospace; user-select: none; }
        canvas { display: block; position: absolute; left: 0; top: 0; z-index: 0; }

        /* UI LAYERS */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; z-index: 1500; }
        .hud-top { position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-between; padding: 0 40px; box-sizing: border-box; font-size: 24px; font-weight: bold; text-shadow: 0 0 8px rgba(0,255,255,0.1); }
        .hud-bottom { position: absolute; bottom: 20px; width: 100%; padding: 0 40px; box-sizing: border-box; display: flex; gap: 20px; align-items: flex-end; pointer-events: none; }
        
        /* BARS */
        .bar-container { width: 300px; height: 20px; background: rgba(0,0,0,0.5); border: 2px solid #333; position: relative; pointer-events: auto; }
        .bar-fill { height: 100%; width: 0%; transition: width 0.2s; }
        #xp-bar-fill { background: #ffd700; box-shadow: 0 0 10px #ffd700; }
        #hp-bar-fill { background: #ff0055; box-shadow: 0 0 10px #ff0055; width: 100%; }
        .bar-text { position: absolute; top: -25px; left: 0; color: #fff; font-size: 14px; }

        /* ABILITY SLOTS */
        .ability-dock { display: flex; gap: 15px; margin-left: auto; pointer-events: auto; }
        .ability-slot { width: 50px; height: 50px; border: 2px solid #333; background: rgba(0,0,0,0.8); position: relative; display: none; align-items: center; justify-content: center; font-size: 20px; color: #fff; }
        .ability-fill { position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(0, 255, 255, 0.3); height: 0%; transition: height 0.1s linear; }
        .ability-slot.ready { border-color: #00ffff; color: #00ffff; box-shadow: 0 0 15px #00ffff; }

        /* MENUS */
        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 2000; pointer-events: auto; }
        h1 { font-size: 80px; margin: 0; text-shadow: 0 0 20px #00ffff; color: #fff; letter-spacing: 5px; }
        button { background: transparent; border: 2px solid #00ffff; color: #00ffff; padding: 15px 40px; font-size: 24px; font-family: inherit; cursor: pointer; margin-top: 20px; transition: 0.2s; text-transform: uppercase; pointer-events: auto; }
        button:hover { background: #00ffff; color: #000; box-shadow: 0 0 20px #00ffff; }
        input { background: transparent; border: none; border-bottom: 2px solid #555; color: #fff; font-family: inherit; font-size: 30px; text-align: center; margin: 20px; width: 350px; outline: none; pointer-events: auto; }
        input:focus { border-color: #00ffff; }

        /* START SCREEN LAYOUT - three-button row: leaderboard left, start center, shop right */
        .start-controls { width: 70%; max-width: 900px; display: flex; align-items: center; justify-content: space-between; margin-top: 20px; gap: 20px; pointer-events: auto; }
        .start-controls .side-btn { flex: 1; display:flex; justify-content:center; }
        .start-controls .center-btn { flex: 0 0 260px; display:flex; justify-content:center; }

        /* SHOP */
        #shop-content { display: flex; flex-direction: column; gap: 10px; width: 70%; max-height: 60vh; overflow-y: auto; background: rgba(0,0,0,0.5); padding: 20px; border: 1px solid #333; }
        .shop-row { display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.05); padding: 10px; border: 1px solid #333; }
        .shop-info { display: flex; align-items: center; gap: 15px; }
        .shop-preview { width: 40px; height: 40px; border: 2px solid #555; display: flex; align-items: center; justify-content: center; font-size: 20px; }
        .buy-btn { font-size: 14px; padding: 5px 15px; margin: 0; min-width: 100px; cursor: pointer; }
        .buy-btn.equipped { background: #00ff00; border-color: #00ff00; color: #000; pointer-events: none; }
        .buy-btn:disabled { border-color: #555; color: #555; cursor: not-allowed; }
        .buy-btn:disabled:hover { background: transparent; box-shadow: none; }
        .shop-section-title { color: #888; margin-top: 15px; border-bottom: 1px solid #444; padding-bottom: 5px; }

        /* UPGRADE CARDS */
        #upgrade-menu { display: none; }
        #cards { display: flex; gap: 20px; margin-top: 40px; }
        .card { width: 220px; height: 320px; background: #111; border: 2px solid #444; padding: 20px; display: flex; flex-direction: column; align-items: center; text-align: center; cursor: pointer; transition: transform 0.15s; position: relative; pointer-events: auto; }
        .card:hover { transform: translateY(-10px); border-color: #fff; box-shadow: 0 0 30px rgba(255,255,255,0.2); }
        .card h3 { color: #ffd700; margin: 10px 0; font-size: 22px; }
        .card p { color: #aaa; font-size: 14px; line-height: 1.4; }
        .rarity { width: 100%; height: 5px; background: #444; position: absolute; top: 0; left: 0; }
        .limit-tag { position: absolute; bottom: 10px; font-size: 12px; color: #666; }

        /* LEADERBOARD - updated highlighting styles */
        #leaderboard-content { width: 500px; max-height: 60vh; overflow-y: auto; border: 1px solid #333; padding: 20px; background: rgba(0,0,0,0.8); }
        .lb-row { display: flex; justify-content: space-between; padding: 10px; border-bottom: 1px solid #222; font-size: 18px; color: #aaa; }
        .gold { color: #ffd700 !important; background: rgba(255,215,0,0.06); font-weight: bold; text-shadow: 0 0 8px rgba(255,215,0,0.4); }
        .silver { color: #c0c7cf !important; background: rgba(192,192,192,0.04); font-weight: bold; text-shadow: 0 0 6px rgba(200,200,200,0.2); }
        .bronze { color: #d08a3a !important; background: rgba(205,127,50,0.03); font-weight: bold; text-shadow: 0 0 6px rgba(208,138,58,0.15); }
        .lb-highlight { color: #7feaff !important; background: rgba(127,234,255,0.06); font-weight: bold; text-shadow: 0 0 12px rgba(127,234,255,0.6); }

        #coin-anim { position: absolute; top: 80px; left: 60px; color: #ffd700; font-size: 20px; font-weight: bold; opacity: 0; transition: 0.5s; pointer-events: none; }

        /* MOBILE JOYSTICK */
        #joystick { position: fixed; left: 24px; bottom: 24px; width: 160px; height: 160px; border-radius: 50%; background: rgba(0,0,0,0.25); border: 2px solid rgba(255,255,255,0.06); display: none; z-index: 200; touch-action: none; }
        #joystick .base { position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); width: 120px; height: 120px; border-radius: 50%; background: rgba(255,255,255,0.02); display: flex; align-items: center; justify-content: center; }
        #joystick .knob { width: 56px; height: 56px; border-radius: 50%; background: rgba(0,255,255,0.12); border: 2px solid rgba(0,255,255,0.25); transform: translate(0,0); transition: 0.02s; }
        #joystick .hint { position: absolute; bottom: -22px; left: 50%; transform: translateX(-50%); font-size: 12px; color: #888; }

        /* Show joystick on touch devices */
        @media (hover: none) and (pointer: coarse) {
            #joystick { display: block; }
            #ui-layer { pointer-events: auto; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- Mobile Joystick -->
    <div id="joystick" aria-hidden="true">
        <div class="base"><div class="knob" id="joystick-knob"></div></div>
        <div class="hint">MOVE</div>
    </div>

    <div id="ui-layer">
        <div class="hud-top">
            <span id="score-text">KILLS: 0</span>
            <span id="time-text">00:00</span>
            <span id="level-text">LVL: 1</span>
        </div>
        <div id="coin-anim">+1 ü™ô</div>
        <div class="hud-bottom">
            <div class="bar-container">
                <span class="bar-text" id="hp-text">100 / 100</span>
                <div class="bar-fill" id="hp-bar-fill"></div>
            </div>
            <div class="bar-container" style="width: 100%; height: 10px; border-color: #444;">
                <div class="bar-fill" id="xp-bar-fill"></div>
            </div>
            <div class="ability-dock">
                <div class="ability-slot" id="slot-laser">L<div class="ability-fill" id="fill-laser"></div></div>
                <div class="ability-slot" id="slot-mine">M<div class="ability-fill" id="fill-mine"></div></div>
            </div>
        </div>
    </div>

    <div id="start-screen" class="screen">
        <h1>NEON SWARM</h1>
        <p style="color: #888; letter-spacing: 2px; margin-bottom: 20px;">WASD to Move ‚Ä¢ MOUSE to Aim</p>
        <input type="text" id="player-name" placeholder="ENTER NAME" maxlength="15" />
        <div class="start-controls">
            <div class="side-btn">
                <button id="btn-leaderboard">RANKINGS</button>
            </div>
            <div class="center-btn">
                <button id="btn-start">START</button>
            </div>
            <div class="side-btn">
                <button id="btn-shop">SHOP (<span id="coin-count">0</span> ü™ô)</button>
            </div>
        </div>
    </div>

    <div id="shop-screen" class="screen" style="display:none;">
        <h2>ARMORY</h2>
        <div style="margin-bottom: 15px; color:#ffd700;">BALANCE: <span id="shop-coins">0</span> ü™ô</div>
        <div id="shop-content"></div>
        <button id="btn-shop-back" style="margin-top: 20px;">BACK</button>
    </div>

    <div id="leaderboard-screen" class="screen" style="display:none;">
        <h2>GLOBAL RANKINGS</h2>
        <div id="leaderboard-content">LOADING...</div>
        <button id="btn-leaderboard-back" style="margin-top: 20px;">BACK</button>
    </div>

    <div id="upgrade-menu" class="screen" style="background: rgba(0,0,0,0.9); display:none;">
        <h2 style="color: #fff; text-shadow: none;">SYSTEM UPGRADE</h2>
        <div id="cards"></div>
    </div>

    <div id="death-screen" class="screen" style="display:none;">
        <h1 style="color: #ff0055; text-shadow: 0 0 30px #ff0055;">CRITICAL FAILURE</h1>
        <p id="final-stats" style="font-size: 24px; margin-top: 20px; color: #fff;"></p>
        <p style="color: #888; font-size: 14px; margin-top: 10px;">SCORE SAVED TO CLOUD</p>
        <div style="display:flex; gap:20px;">
            <button id="btn-reboot">REBOOT SYSTEM</button>
            <button id="btn-mainmenu">MAIN MENU</button>
        </div>
    </div>

    <script type="module">
    // Dynamic firebase import so failures won't break the game
    let db = null;
    const firebaseConfig = {
        apiKey: "AIzaSyD6rmIdWG1pm695Q_0Zcapbwcx8JlvgpHY",
        authDomain: "neon-swarm.firebaseapp.com",
        projectId: "neon-swarm",
        storageBucket: "neon-swarm.firebasestorage.app",
        messagingSenderId: "982908895215",
        appId: "1:982908895215:web:379252fdb7138262bec01a",
        measurementId: "G-XGFTTFLM4K"
    };
    async function initFirebase() {
        try {
            const appMod = await import("https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js");
            const fsMod = await import("https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js");
            const { initializeApp } = appMod;
            const { getFirestore } = fsMod;
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            window._firestoreModules = fsMod;
            console.log("Firebase ready");
        } catch (e) {
            console.warn("Firebase not available:", e);
            db = null;
        }
    }

    // Canvas + game state
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const root = document.documentElement;
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize);
    resize();

    // Game variables
    let gameActive = false, isPaused = false, isDying = false, deathTimer = 0, frame = 0;
    let camera = { x: 0, y: 0 }, globalDifficulty = 1;

    // Persistent
    let totalCoins = 0, playerName = "", inventory = ['skin_default', 'bg_default', 'proj_orb', 'trail_none', 'ui_default', 'death_default'];
    let equipped = { skin: 'skin_default', bg: 'bg_default', proj: 'proj_orb', trail: 'trail_none', ui: 'ui_default', death: 'death_default' };

    // Player
    let player = {
        x: 0, y: 0, hp: 100, maxHp: 100, regenTimer: 0, invulnTimer: 0,
        speed: 5, size: 15, level: 1, xp: 0, nextXp: 50, score: 0,
        fireRate: 25, bulletDmg: 20, bulletSpeed: 12, bulletCount: 1, pierce: 0, pickupRange: 150,
        orbitals: 0, meteorLevel: 0, lastMeteor: 0, laserLevel: 0, lastLaser: 0, mineLevel: 0, lastMine: 0
    };

    let bullets = [], enemies = [], particles = [], gems = [], damageText = [], meteors = [], lasers = [], mines = [], trailParticles = [];
    const keys = {};
    window.addEventListener('keydown', e => { keys[e.key] = true; keys[e.code] = true; });
    window.addEventListener('keyup', e => { keys[e.key] = false; keys[e.code] = false; });

    // Cosmetics (expanded & higher prices)
    const cosmetics = [
        { id: 'skin_default', type: 'skin', name: 'NEON CYAN', color: '#00ffff', cost: 0 },
        { id: 'skin_red', type: 'skin', name: 'CRIMSON FURY', color: '#ff0000', cost: 100 },
        { id: 'skin_gold', type: 'skin', name: 'MIDAS TOUCH', color: '#ffd700', cost: 250 },
        { id: 'skin_void', type: 'skin', name: 'VOID WALKER', color: '#aa00ff', cost: 150 },
        { id: 'skin_glitch', type: 'skin', name: 'GLITCH CORE', color: '#00ff88', cost: 200 },
        { id: 'skin_neonwave', type: 'skin', name: 'NEON WAVE', color: '#ff55ff', cost: 220 },

        { id: 'bg_default', type: 'bg', name: 'DEEP SPACE', bg: '#050505', grid: '#222', cost: 0 },
        { id: 'bg_matrix', type: 'bg', name: 'THE MATRIX', bg: '#001100', grid: '#004400', cost: 150 },
        { id: 'bg_retro', type: 'bg', name: 'RETRO WAVE', bg: '#110011', grid: '#440044', cost: 200 },
        { id: 'bg_cosmos', type: 'bg', name: 'COSMOS RIFT', bg: '#001122', grid: '#113355', cost: 300 },

        { id: 'proj_orb', type: 'proj', name: 'PLASMA ORB', symbol: '', color: '#ffff00', cost: 0 },
        { id: 'proj_star', type: 'proj', name: 'STAR POWER', symbol: '‚òÖ', color: '#ffaa00', cost: 250 },
        { id: 'proj_note', type: 'proj', name: 'SOUND WAVES', symbol: '‚ô™', color: '#00ff88', cost: 200 },
        { id: 'proj_skull', type: 'proj', name: 'DEATH TOUCH', symbol: 'üíÄ', color: '#cccccc', cost: 300 },
        { id: 'proj_bin', type: 'proj', name: 'BINARY', symbol: '10', color: '#00ff00', cost: 200 },
        { id: 'proj_comet', type: 'proj', name: 'COMET TRAIL', symbol: '', color: '#ff9900', cost: 260 },

        { id: 'trail_none', type: 'trail', name: 'NO TRAIL', color: 'transparent', cost: 0 },
        { id: 'trail_rain', type: 'trail', name: 'RAINBOW', color: 'rainbow', cost: 300 },
        { id: 'trail_smoke', type: 'trail', name: 'ENGINE SMOKE', color: '#555', cost: 150 },
        { id: 'trail_pixie', type: 'trail', name: 'PIXIE DUST', color: '#ffccff', cost: 250 },
        { id: 'trail_bub', type: 'trail', name: 'BUBBLES', color: '#0088ff', cost: 200 },
        { id: 'trail_electro', type: 'trail', name: 'ELECTRO STREAM', color: '#66ffcc', cost: 320 },

        { id: 'ui_default', type: 'ui', name: 'DEFAULT CYAN', hud: '#00ffff', shadow: '#0088ff', cost: 0 },
        { id: 'ui_pink', type: 'ui', name: 'CYBER PUNK', hud: '#ff00ff', shadow: '#aa00aa', cost: 200 },
        { id: 'ui_gold', type: 'ui', name: 'LUXURY GOLD', hud: '#ffd700', shadow: '#aa7700', cost: 300 },
        { id: 'ui_white', type: 'ui', name: 'MINIMALIST', hud: '#ffffff', shadow: '#888888', cost: 150 },
        { id: 'ui_neonmix', type: 'ui', name: 'NEON MIX', hud: '#ffcc00', shadow: '#ff66cc', cost: 260 },

        { id: 'death_default', type: 'death', name: 'STANDARD', cost: 0 },
        { id: 'death_conf', type: 'death', name: 'CONFETTI', cost: 250 },
        { id: 'death_hole', type: 'death', name: 'BLACK HOLE', cost: 600 },
        { id: 'death_supernova', type: 'death', name: 'SUPERNOVA', cost: 1000 }
    ];

    // Save / Load
    function loadData() {
        try {
            let saved = localStorage.getItem('neon_swarm_data_v3');
            if (saved) {
                let data = JSON.parse(saved);
                totalCoins = data.coins || 0;
                playerName = data.name || "";
                inventory = data.inventory || inventory;
                if (data.equipped) equipped = { ...equipped, ...data.equipped };
            }
        } catch (e) { console.warn("loadData parse failed", e); }

        if (!playerName || playerName.trim() === "") playerName = "GUEST" + Math.floor(1000 + Math.random() * 9000);
        applyTheme();
        const pn = document.getElementById('player-name');
        const cc = document.getElementById('coin-count');
        if (pn) pn.value = playerName;
        if (cc) cc.innerText = totalCoins;
    }
    function saveData() {
        try {
            let data = { coins: totalCoins, name: playerName, inventory: inventory, equipped: equipped };
            localStorage.setItem('neon_swarm_data_v3', JSON.stringify(data));
        } catch (e) { console.warn("saveData failed", e); }
    }
    function updateName(val) { playerName = val.toUpperCase(); saveData(); }
    function applyTheme() {
        let ui = cosmetics.find(c => c.id === equipped.ui) || cosmetics.find(c => c.id === 'ui_default');
        root.style.setProperty('--hud-color', ui.hud || '#00ffff');
        root.style.setProperty('--hud-shadow', ui.shadow || '#0088ff');
        const lvl = document.getElementById('level-text');
        if (lvl) lvl.style.color = ui.hud || '#00ffff';
    }

    // Joystick
    const joystick = { el: document.getElementById('joystick'), knob: document.getElementById('joystick-knob'), active: false, dx: 0, dy: 0, maxRadius: 48 };
    function setupJoystick() {
        let base = joystick.el;
        if (!base) return;
        let rect = base.getBoundingClientRect();
        function getTouchPoint(t) { return { x: t.clientX, y: t.clientY }; }
        base.addEventListener('touchstart', (ev) => {
            ev.preventDefault();
            joystick.active = true;
            rect = base.getBoundingClientRect();
            let t = ev.changedTouches[0];
            let center = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
            let p = getTouchPoint(t);
            let vx = p.x - center.x, vy = p.y - center.y;
            let dist = Math.hypot(vx, vy);
            if (dist > joystick.maxRadius) { vx = vx / dist * joystick.maxRadius; vy = vy / dist * joystick.maxRadius; }
            joystick.knob.style.transform = `translate(${vx}px, ${vy}px)`;
            joystick.dx = vx / joystick.maxRadius;
            joystick.dy = vy / joystick.maxRadius;
        }, { passive: false });
        base.addEventListener('touchmove', (ev) => {
            if (!joystick.active) return;
            ev.preventDefault();
            rect = base.getBoundingClientRect();
            let t = ev.changedTouches[0];
            let center = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
            let p = getTouchPoint(t);
            let vx = p.x - center.x, vy = p.y - center.y;
            let dist = Math.hypot(vx, vy);
            if (dist > joystick.maxRadius) { vx = vx / dist * joystick.maxRadius; vy = vy / dist * joystick.maxRadius; }
            joystick.knob.style.transform = `translate(${vx}px, ${vy}px)`;
            joystick.dx = vx / joystick.maxRadius;
            joystick.dy = vy / joystick.maxRadius;
        }, { passive: false });
        base.addEventListener('touchend', (ev) => {
            joystick.active = false;
            joystick.dx = 0; joystick.dy = 0;
            joystick.knob.style.transform = `translate(0px, 0px)`;
        });
        base.addEventListener('touchcancel', (ev) => {
            joystick.active = false;
            joystick.dx = 0; joystick.dy = 0;
            joystick.knob.style.transform = `translate(0px, 0px)`;
        });
        window.addEventListener('touchstart', function onFirstTouch() {
            joystick.el.style.display = 'block';
            window.removeEventListener('touchstart', onFirstTouch);
        }, { passive: true });
    }

    // Cloud leaderboard helpers (if firebase loaded)
    async function saveScoreToCloud(name, score) {
        if (!db || !window._firestoreModules) return;
        try {
            const { collection, addDoc, query, getDocs, where, updateDoc, doc } = window._firestoreModules;
            const q = query(collection(db, "leaderboard"), where("name", "==", name));
            const querySnapshot = await getDocs(q);
            if (!querySnapshot.empty) {
                querySnapshot.forEach(async (docSnap) => {
                    const oldScore = docSnap.data().score;
                    if (score > oldScore) {
                        await updateDoc(doc(db, "leaderboard", docSnap.id), { score: score, date: Date.now() });
                    }
                });
            } else {
                await addDoc(collection(db, "leaderboard"), { name: name, score: score, date: Date.now() });
            }
        } catch (e) { console.error("Error saving score:", e); }
    }
    async function getLeaderboardFromCloud() {
        if (!db || !window._firestoreModules) return [];
        try {
            const { collection, query, orderBy, getDocs } = window._firestoreModules;
            // show everyone: remove any limit
            const q = query(collection(db, "leaderboard"), orderBy("score", "desc"));
            const querySnapshot = await getDocs(q);
            let results = [];
            querySnapshot.forEach((d) => results.push(d.data()));
            return results;
        } catch (e) { console.error("Error getting leaderboard:", e); return []; }
    }

    // --- SHOP ---
    function renderShop() {
        const shopCoins = document.getElementById('shop-coins');
        if (shopCoins) shopCoins.innerText = totalCoins;
        let content = document.getElementById('shop-content');
        if (!content) return;
        content.innerHTML = '';
        let categories = [
            { id: 'skin', name: 'SHIP SKINS' },
            { id: 'bg', name: 'BACKGROUNDS' },
            { id: 'proj', name: 'PROJECTILES' },
            { id: 'trail', name: 'ENGINE TRAILS' },
            { id: 'ui', name: 'HUD THEMES' },
            { id: 'death', name: 'DEATH FX' }
        ];
        categories.forEach(cat => {
            let title = document.createElement('div'); title.className='shop-section-title'; title.innerText = cat.name; content.appendChild(title);
            cosmetics.filter(c => c.type === cat.id).forEach(item => {
                let row = document.createElement('div'); row.className = 'shop-row';
                let owned = inventory.includes(item.id);
                let isEquipped = equipped[cat.id] === item.id;
                let btnText = isEquipped ? "EQUIPPED" : (owned ? "EQUIP" : "BUY " + item.cost + "ü™ô");
                let btnClass = isEquipped ? "buy-btn equipped" : (owned ? "buy-btn" : (totalCoins >= item.cost ? "buy-btn can-buy" : "buy-btn"));
                let prevStyle = "", prevInner = "";
                if(cat.id === 'skin') prevStyle = `background:${item.color}`;
                else if(cat.id === 'bg') prevStyle = `background:${item.bg}; border-color:${item.grid}`;
                else if(cat.id === 'proj') { prevStyle = `background:#000; border-color:${item.color}`; prevInner = item.symbol || '‚óè'; }
                else if(cat.id === 'trail') prevStyle = `background:${item.color === 'rainbow' ? 'linear-gradient(45deg, red, blue)' : item.color}`;
                else if(cat.id === 'ui') prevStyle = `background:${item.hud}`;
                else if(cat.id === 'death') prevStyle = `background:#333; color:red; border-color:red`;
                row.innerHTML = `
                    <div class="shop-info">
                        <div class="shop-preview" style="${prevStyle}; color:${item.color || '#fff'}">${prevInner}</div>
                        <div><h3 style="margin:0; font-size:16px; color:#fff">${item.name}</h3></div>
                    </div>
                    <button class="${btnClass}" ${(!owned && totalCoins < item.cost) ? 'disabled' : ''}>${btnText}</button>
                `;
                let btn = row.querySelector('button');
                btn.onclick = () => {
                    if (inventory.includes(item.id)) {
                        equipped[cat.id] = item.id;
                    } else {
                        if (totalCoins >= item.cost) {
                            totalCoins -= item.cost; inventory.push(item.id); equipped[cat.id] = item.id;
                        }
                    }
                    if (cat.id === 'ui') applyTheme();
                    saveData(); renderShop(); const cc = document.getElementById('coin-count'); if (cc) cc.innerText = totalCoins;
                };
                content.appendChild(row);
            });
        });
    }

    // --- UPGRADES ---
    let upgradePool = [];
    function resetUpgrades() {
        upgradePool = [
            { id: "fire", name: "RAPID FIRE", desc: "Fire Rate +15%", type: "stat", key: "fireRate", val: 0.85, max: 8, count: 0 },
            { id: "multi", name: "MULTISHOT", desc: "+1 Projectile", type: "stat", key: "bulletCount", val: 1, max: 6, count: 0 },
            { id: "dmg", name: "HIGH CALIBER", desc: "Damage +30%", type: "stat", key: "bulletDmg", val: 1.3, max: 10, count: 0 },
            { id: "speed", name: "THRUSTERS", desc: "Move Speed +10%", type: "stat", key: "speed", val: 1.10, max: 5, count: 0 },
            { id: "mag", name: "MAGNET FIELD", desc: "Pickup Range +40%", type: "stat", key: "pickupRange", val: 1.4, max: 5, count: 0 },
            { id: "orb", name: "PLASMA ORBITAL", desc: "Add spinning shield", type: "ability", key: "orbital", max: 5, count: 0 },
            { id: "met", name: "METEOR STRIKE", desc: "Faster Meteor Rain", type: "ability", key: "meteor", max: 5, count: 0 },
            { id: "laser", name: "ION LASER", desc: "Shoot massive beam (10s cd)", type: "ability", key: "laser", max: 4, count: 0 },
            { id: "mine", name: "PROXIMITY MINE", desc: "Drop bomb behind you", type: "ability", key: "mine", max: 5, count: 0 },
            { id: "hull", name: "TITANIUM HULL", desc: "+50 Max HP & Heal", type: "heal", max: 99, count: 0 }
        ];
    }

    // --- NEW: Laser auto-aim function (chooses angle that intersects most enemies),
    // weighted to prefer red/orange/grunt/dasher enemies so it targets the most kills ---
    function findBestLaserAngle() {
        if (enemies.length === 0) return Math.random() * Math.PI * 2;
        const beamHalfWidth = 40;
        const maxRange = 2000;
        let best = { angle: 0, score: -1, avg: Infinity };
        let candidates = [];
        for (let e of enemies) {
            let a = Math.atan2(e.y - player.y, e.x - player.x);
            candidates.push(a, a + 0.06, a - 0.06);
        }
        for (let a of candidates) {
            let score = 0, totalDist = 0;
            for (let e of enemies) {
                let vx = e.x - player.x, vy = e.y - player.y;
                let forward = vx * Math.cos(a) + vy * Math.sin(a);
                if (forward <= 0 || forward > maxRange) continue;
                let perp = Math.abs(-vx * Math.sin(a) + vy * Math.cos(a));
                if (perp <= e.size + beamHalfWidth) {
                    const col = (e.color || "").toLowerCase();
                    if (e.type === 'titan') {
                        score += 0.6;
                    } else if (col === '#ff0055' || col === '#ff8800' || e.type === 'grunt' || e.type === 'dasher') {
                        // prefer red/orange and small aggressive types
                        score += 1.3;
                    } else {
                        score += 1.0;
                    }
                    totalDist += forward;
                }
            }
            if (score > 0) {
                let avg = totalDist / score;
                if (score > best.score || (score === best.score && avg < best.avg)) best = { angle: a, score, avg };
            }
        }
        if (best.score < 0) {
            const n = getNearestEnemy(player.x, player.y, 2000);
            return n ? Math.atan2(n.y - player.y, n.x - player.x) : Math.random() * Math.PI * 2;
        }
        return best.angle;
    }

    // --- GAME START / RESTART ---
    function startGame() {
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('ui-layer').style.display = 'block';
        restartGame();
    }
    function restartGame() {
        gameActive = true; isPaused = false; isDying = false; frame = 0; globalDifficulty = 1;
        player = {
            x: 0, y: 0, hp: 100, maxHp: 100, regenTimer: 0, invulnTimer: 0,
            speed: 5, size: 15, level: 1, xp: 0, nextXp: 50, score: 0,
            fireRate: 25, bulletDmg: 20, bulletSpeed: 12, bulletCount: 1, pierce: 0, pickupRange: 150,
            orbitals: 0, meteorLevel: 0, lastMeteor: 0, laserLevel: 0, lastLaser: 0, mineLevel: 0, lastMine: 0
        };
        resetUpgrades();
        bullets = []; enemies = []; particles = []; gems = []; damageText = []; meteors = []; lasers = []; mines = []; trailParticles = [];
        document.getElementById('death-screen').style.display = 'none';
        document.getElementById('upgrade-menu').style.display = 'none';
        // Start player roughly centered in world
        player.x = 0; player.y = 0;
        updateUI();
    }

    // --- ENTITIES & BEHAVIOR (full logic restored) ---
    function spawnEnemy() {
        let angle = Math.random() * Math.PI * 2;
        let dist = (Math.max(canvas.width, canvas.height) / 2) + 100;
        let x = player.x + Math.cos(angle) * dist;
        let y = player.y + Math.sin(angle) * dist;
        let type = 'grunt', size = 20, hp = 20 * globalDifficulty, speed = 2 + (globalDifficulty*0.2), color = '#ff0055';
        if (player.score > 50 && Math.random() > 0.85) { type = 'dasher'; color = '#ff8800'; speed = 1.5 + (globalDifficulty*0.2); hp = 50 * globalDifficulty; size=25; }
        enemies.push({ x, y, type, size, hp, speed, color, dashMode: false });
    }
    function spawnBoss() {
        let angle = Math.random() * Math.PI * 2;
        let x = player.x + Math.cos(angle) * 600;
        let y = player.y + Math.sin(angle) * 600;
        let bossHp = 300 * globalDifficulty;
        enemies.push({ x, y, type: 'titan', size: 60, hp: bossHp, maxHp: bossHp, speed: 1.8 + (globalDifficulty * 0.2), color: '#aa00ff' });
        camera.x += (Math.random()-0.5)*50;
    }
    function damageEnemy(e, amt) {
        e.hp -= amt;
        damageText.push({ x: e.x, y: e.y, val: Math.floor(amt), life: 1 });
        if (e.hp <= 0 && enemies.includes(e)) {
            enemies.splice(enemies.indexOf(e), 1);
            player.score++;
            if (player.score % 10 === 0) {
                totalCoins++; saveData(); const cc = document.getElementById('coin-count'); if (cc) cc.innerText = totalCoins;
                let anim = document.getElementById('coin-anim'); anim.style.opacity = '1'; anim.style.transform = 'translateY(-20px)';
                setTimeout(() => { anim.style.opacity = '0'; anim.style.transform = 'translateY(0)'; }, 800);
            }
            if (e.type === 'titan') {
                for(let k=0; k<5; k++) gems.push({ x: e.x + (Math.random()-0.5)*50, y: e.y + (Math.random()-0.5)*50, val: 150, mag: false });
            } else {
                gems.push({ x: e.x, y: e.y, val: 5 + Math.floor(globalDifficulty), mag: false });
            }
            updateUI();
        }
    }

    function spawnParticles(x, y, color, count) { for(let i=0;i<count;i++) particles.push({ x, y, color, vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5, life: 1 }); }

    function getNearestEnemies(x, y, range) {
        let list = enemies.map(e => ({ e: e, dist: Math.hypot(x - e.x, y - e.y) }));
        list = list.filter(item => item.dist < range).sort((a, b) => a.dist - b.dist);
        return list.map(item => item.e);
    }
    function getNearestEnemy(x, y, range) {
        let nearest = null; let minDst = range;
        enemies.forEach(e => { let d = Math.hypot(x-e.x, y-e.y); if(d < minDst) { minDst = d; nearest = e; } });
        return nearest;
    }

    function shoot() {
        let targets = getNearestEnemies(player.x, player.y, 650);
        if (targets.length === 0) return;
        for (let i = 0; i < player.bulletCount; i++) {
            let target = targets[i % targets.length];
            let angle = Math.atan2(target.y - player.y, target.x - player.x);
            angle += (Math.random() - 0.5) * 0.1;
            bullets.push({ x: player.x, y: player.y, angle: angle, size: 5, hits: 0, life: 60 });
        }
    }
    function fireLaser() {
        // Use auto-aim that maximizes number of hits
        const baseAngle = findBestLaserAngle();
        const count = player.laserLevel || 1;
        const angles = count === 1 ? [0] : count === 2 ? [0, Math.PI] : count === 3 ? [0, 0.06, -0.06] : [0, 0.08, -0.08, 0.16];
        angles.forEach(a => lasers.push({ x: player.x, y: player.y, angle: baseAngle + a, life: 1.0, width: 40 }));
    }
    function dropMine() { mines.push({ x: player.x, y: player.y, timer: 150, dmg: player.bulletDmg * 8 }); }
    function triggerMeteor() {
        let tx, ty;
        if (enemies.length > 0) { let e = enemies[Math.floor(Math.random() * enemies.length)]; tx = e.x; ty = e.y; }
        else { let a = Math.random()*Math.PI*2, d = 100+Math.random()*200; tx = player.x+Math.cos(a)*d; ty = player.y+Math.sin(a)*d; }
        meteors.push({ x: tx, y: ty, radius: 120 + (player.meteorLevel * 10), timer: 45 });
    }

    function gainXp(amt) {
        player.xp += amt;
        if (player.xp >= player.nextXp) { player.xp = 0; player.nextXp = Math.floor(player.nextXp * 1.3); player.level++; showUpgrades(); }
        updateUI();
    }
    function takeDamage(amt) {
        if (player.invulnTimer > 0) return;
        player.hp -= amt; player.invulnTimer = 30; updateUI();
        if (player.hp <= 0) triggerDeath();
    }

    // --- ENTITY UPDATES (movement, collisions) ---
    function updateEntities() {
        // Trail
        for(let i=trailParticles.length-1;i>=0;i--) {
            let p = trailParticles[i]; p.life -= 0.02;
            if (p.type === 'trail_smoke') { p.y -= 1; p.size += 0.2; }
            if (p.type === 'trail_bub') { p.x += Math.sin(frame/10 + i)*0.5; p.y += Math.cos(frame/10)*0.5; }
            if (p.life <= 0) trailParticles.splice(i,1);
        }

        // Lasers
        for(let i=lasers.length-1;i>=0;i--) {
            let l = lasers[i]; l.life -= 0.05;
            if (l.life > 0.8) {
                enemies.forEach(e => {
                    let vx = e.x - l.x, vy = e.y - l.y;
                    let rx = vx * Math.cos(-l.angle) - vy * Math.sin(-l.angle);
                    let ry = vx * Math.sin(-l.angle) + vy * Math.cos(-l.angle);
                    if (Math.abs(ry) < e.size + l.width && rx > 0) {
                        // One-shot red/orange enemies
                        const col = (e.color || "").toLowerCase();
                        if (col === '#ff0055' || col === '#ff8800') {
                            damageEnemy(e, e.hp);
                        } else {
                            damageEnemy(e, 30);
                        }
                    }
                });
            }
            if (l.life <= 0) lasers.splice(i,1);
        }

        // Mines
        for(let i=mines.length-1;i>=0;i--) {
            let m = mines[i]; m.timer--;
            if (m.timer <= 0) {
                spawnParticles(m.x, m.y, '#ffaa00', 20);
                enemies.forEach(e => { if (Math.hypot(m.x-e.x, m.y-e.y) < 250) damageEnemy(e, m.dmg); });
                mines.splice(i,1);
            }
        }

        // Bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i];
            b.x += Math.cos(b.angle) * player.bulletSpeed;
            b.y += Math.sin(b.angle) * player.bulletSpeed;
            b.life--;
            let hit = false;
            for (let e of enemies) {
                if (Math.hypot(b.x - e.x, b.y - e.y) < e.size + b.size) {
                    damageEnemy(e, player.bulletDmg);
                    spawnParticles(b.x, b.y, (cosmetics.find(c=>c.id===equipped.proj) || {}).color || '#fff', 3);
                    b.hits++; if (b.hits > player.pierce) hit = true; break;
                }
            }
            if (hit || b.life <= 0) bullets.splice(i,1);
        }

        // Spawn enemies
        let spawnRate = Math.max(1, 40 - (player.level*1.5 + (frame/600)));
        if (frame % Math.floor(spawnRate) === 0) spawnEnemy();
        if (frame > 0 && frame % 1800 === 0) spawnBoss();

        // Enemies movement & collision with player
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            let angle = Math.atan2(player.y - e.y, player.x - e.x);
            e.x += Math.cos(angle) * e.speed;
            e.y += Math.sin(angle) * e.speed;

            if (e.type === 'dasher') {
                if (!e.dashMode) { if (Math.random() < 0.01) { e.dashMode = true; e.dashTimer = 30; } }
                else {
                    e.dashTimer--;
                    if (e.dashTimer <= 0) {
                         e.x += Math.cos(angle) * 12; e.y += Math.sin(angle) * 12;
                         if (Math.random() < 0.1) e.dashMode = false;
                    }
                }
            }
            if (player.orbitals > 0) {
                let dist = Math.hypot(player.x - e.x, player.y - e.y);
                // orbitals spin just a bit faster than original: check every 8 frames (original was 10)
                if (dist < 100 && frame % 8 === 0) {
                    // One-shot red/orange enemies
                    const col = (e.color || "").toLowerCase();
                    if (col === '#ff0055' || col === '#ff8800') {
                        damageEnemy(e, e.hp);
                    } else {
                        damageEnemy(e, player.bulletDmg * 0.8);
                    }
                    spawnParticles(e.x, e.y, '#00ffff', 2);
                }
            }
            let dist = Math.hypot(player.x - e.x, player.y - e.y);
            if (dist < player.size + e.size) { takeDamage(e.type === 'titan' ? 40 : 10); }
            if (dist > 2500) enemies.splice(i,1);
        }

        // Meteors
        for (let i = meteors.length - 1; i >= 0; i--) {
            let m = meteors[i]; m.timer--;
            if (m.timer <= 0) {
                spawnParticles(m.x, m.y, '#ff5500', 30);
                enemies.forEach(e => { if (Math.hypot(m.x - e.x, m.y - e.y) < m.radius) damageEnemy(e, player.bulletDmg * 10); });
                meteors.splice(i, 1);
            }
        }

        // Gems magnet & pickup -> XP
        for (let i = gems.length - 1; i >= 0; i--) {
            let g = gems[i];
            let dist = Math.hypot(player.x - g.x, player.y - g.y);
            if (dist < player.pickupRange) g.mag = true;
            if (g.mag) {
                let angle = Math.atan2(player.y - g.y, player.x - g.x);
                let speed = player.speed + 8;
                g.x += Math.cos(angle) * speed;
                g.y += Math.sin(angle) * speed;
                if (dist < player.size + 10) { gainXp(g.val); gems.splice(i,1); }
            }
        }

        // Particles & damage text decay
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx; p.y += p.vy; p.life -= 0.05; if (p.life <= 0) particles.splice(i,1);
        }
        for (let i = damageText.length - 1; i >= 0; i--) {
            let d = damageText[i];
            d.y -= 1; d.life -= 0.02; if (d.life <= 0) damageText.splice(i,1);
        }
    }

    // --- TELEGRAPHS ---
    function drawTelegraphs(sx, sy) {
        // Laser Telegraph (use auto-aim)
        if (player.laserLevel > 0) {
            let passed = frame - player.lastLaser;
            if (passed > 500) {
                let angle = findBestLaserAngle();
                let opacity = (passed - 500) / 100;
                ctx.save(); ctx.translate(sx, sy); ctx.rotate(angle);
                ctx.fillStyle = `rgba(0, 255, 255, ${Math.min(0.45, opacity * 0.3)})`;
                ctx.fillRect(0, -1, 2000, 2);
                ctx.restore();
            }
        }
        // Mine Telegraph
        if (player.mineLevel > 0) {
            let cd = Math.max(90, 300 - (player.mineLevel * 40));
            let passed = frame - player.lastMine;
            if (passed > cd - 60) {
                let alpha = (Math.sin(frame/5) + 1) / 2;
                ctx.save(); ctx.translate(sx, sy);
                ctx.strokeStyle = `rgba(255, 50, 0, ${alpha})`;
                ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.stroke();
                ctx.restore();
            }
        }
    }

    // --- DRAW ---
    function draw() {
        let curBg = cosmetics.find(c => c.id === equipped.bg) || cosmetics[5];
        let curSkin = cosmetics.find(c => c.id === equipped.skin) || cosmetics[0];
        let curProj = cosmetics.find(c => c.id === equipped.proj) || cosmetics.find(c => c.type==='proj');

        // Background
        ctx.fillStyle = curBg.bg || '#050505'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = curBg.grid || '#222'; ctx.lineWidth = 2; ctx.beginPath();
        let gs = 100, ox = -camera.x % gs, oy = -camera.y % gs;
        for (let x = ox; x < canvas.width; x += gs) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
        for (let y = oy; y < canvas.height; y += gs) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
        ctx.stroke();

        function drawAt(x, y, fn) { let sx = x - camera.x, sy = y - camera.y; if (sx<-2000||sx>canvas.width+2000||sy<-2000||sy>canvas.height+2000) return; ctx.save(); ctx.translate(sx, sy); fn(); ctx.restore(); }

        // Telegraphs
        if (!isDying) drawTelegraphs(player.x - camera.x, player.y - camera.y);

        // Trail particles
        trailParticles.forEach(p => drawAt(p.x, p.y, () => {
            ctx.fillStyle = p.color; ctx.globalAlpha = p.life;
            if (p.type === 'trail_pixie') { ctx.translate(Math.random()*2, Math.random()*2); ctx.fillRect(0,0,p.size,p.size); }
            else if (p.type === 'trail_bub') { ctx.strokeStyle = p.color; ctx.beginPath(); ctx.arc(0,0,p.size,0,Math.PI*2); ctx.stroke(); }
            else { ctx.beginPath(); ctx.arc(0,0,p.size,0,Math.PI*2); ctx.fill(); }
            ctx.globalAlpha = 1;
        }));

        // Mines
        mines.forEach(m => drawAt(m.x, m.y, () => {
            let f = Math.floor(Date.now()/100)%2===0; ctx.fillStyle=f?'#ff0000':'#440000'; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
            ctx.strokeStyle = 'rgba(255,0,0,0.2)'; ctx.beginPath(); ctx.arc(0,0,250*(1-(m.timer/150)),0,Math.PI*2); ctx.stroke();
        }));

        // Gems
        gems.forEach(g => drawAt(g.x, g.y, () => { ctx.fillStyle = '#00ff00'; ctx.beginPath(); ctx.arc(0,0, 5, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur=10;ctx.shadowColor='#00ff00';ctx.fill(); ctx.shadowBlur=0; }));

        // Lasers
        lasers.forEach(l => drawAt(l.x, l.y, () => { ctx.rotate(l.angle); ctx.fillStyle=`rgba(0,255,255,${l.life})`; ctx.fillRect(0,-l.width/2,2000,l.width); }));

        // Meteors
        meteors.forEach(m => drawAt(m.x, m.y, () => { ctx.strokeStyle = `rgba(255,50,0,${0.5+Math.random()*0.5})`; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(0,0,m.radius,0,Math.PI*2); ctx.stroke(); }));

        // Enemies
        enemies.forEach(e => drawAt(e.x, e.y, () => {
            ctx.fillStyle = e.color;
            if (e.type === 'titan') {
                ctx.shadowBlur=20; ctx.shadowColor='#aa00ff'; ctx.fillRect(-e.size/2,-e.size/2,e.size,e.size); ctx.shadowBlur=0;
                ctx.fillStyle='red'; ctx.fillRect(-30,-e.size,60,5); ctx.fillStyle='#0f0'; ctx.fillRect(-30,-e.size,60*(e.hp/e.maxHp),5);
            } else if (e.type==='dasher') { ctx.beginPath();ctx.arc(0,0,e.size/2,0,Math.PI*2);ctx.fill();ctx.strokeStyle='white';ctx.stroke(); }
            else ctx.fillRect(-e.size/2,-e.size/2,e.size,e.size);
        }));

        // Player
        if (!isDying) {
            ctx.save(); ctx.translate(player.x - camera.x, player.y - camera.y);
            if (player.orbitals > 0) {
                // spin just a bit faster than original: original ~0.002, use 0.0035
                let t = Date.now() * 0.0035;
                for(let i=0;i<player.orbitals;i++) {
                    let a = t + (i * (Math.PI*2/player.orbitals));
                    ctx.beginPath(); ctx.arc(Math.cos(a)*80, Math.sin(a)*80, 8, 0, Math.PI*2); ctx.fillStyle = curSkin.color; ctx.fill(); ctx.shadowBlur=15;ctx.shadowColor=curSkin.color;ctx.fill(); ctx.shadowBlur=0;
                }
            }
            ctx.fillStyle = (player.invulnTimer > 0 && Math.floor(Date.now()/50)%2===0) ? 'red' : curSkin.color;
            ctx.fillRect(-10, -10, 20, 20);
            ctx.shadowBlur = 10; ctx.shadowColor = curSkin.color; ctx.strokeRect(-10,-10,20,20);
            ctx.restore();
        }

        // Bullets
        bullets.forEach(b => drawAt(b.x, b.y, () => {
            ctx.fillStyle = (curProj && curProj.color) || '#fff';
            if (curProj && curProj.symbol) {
                ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline='middle';
                if (curProj.id === 'proj_bin') ctx.fillText(Math.random()>0.5?'1':'0', 0, 0);
                else ctx.fillText(curProj.symbol, 0, 0);
            } else {
                ctx.beginPath(); ctx.arc(0,0, 4, 0, Math.PI*2); ctx.fill();
            }
        }));

        // Particles
        particles.forEach(p => drawAt(p.x, p.y, () => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.fillRect(0,0, 4, 4); ctx.globalAlpha = 1; }));

        // Damage text
        ctx.fillStyle = '#fff'; ctx.font = "bold 14px Arial";
        damageText.forEach(d => drawAt(d.x, d.y, () => ctx.fillText(d.val, 0, 0)));
    }

    // --- DEATH & UPGRADES ---
    function triggerDeath() {
        gameActive = false;
        isDying = true;
        deathTimer = 0;
        if (player.score > 0) saveScoreToCloud(playerName, player.score);
        if (equipped.death === 'death_conf') {
            for (let i=0;i<100;i++) {
                particles.push({ x: player.x, y: player.y, color: `hsl(${Math.random()*360},100%,50%)`, vx:(Math.random()-0.5)*15, vy:(Math.random()-0.5)*15, life:2.0 });
            }
        }
    }
    function drawDeathAnim() {
        draw();
        deathTimer++;
        ctx.save();
        ctx.translate(player.x - camera.x, player.y - camera.y);
        if (equipped.death === 'death_hole') {
            let size = deathTimer * 20;
            ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(0,0,size,0,Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
        }
        if (equipped.death === 'death_supernova') {
            let r = 20 + deathTimer * 6;
            ctx.beginPath(); ctx.fillStyle = `rgba(255, ${Math.min(255,deathTimer*6)}, 0, 0.8)`; ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
        }
        ctx.restore();
        if (deathTimer > 60) {
            isDying = false;
            document.getElementById('death-screen').style.display = 'flex';
            document.getElementById('final-stats').innerText = "KILLS: " + player.score + " | LVL: " + player.level;
        }
    }

    function showUpgrades() {
        isPaused = true;
        let menu = document.getElementById('upgrade-menu');
        let container = document.getElementById('cards');
        container.innerHTML = "";
        menu.style.display = 'flex';
        let available = upgradePool.filter(u => u.count < u.max);
        if (available.length === 0) available = [upgradePool.find(u => u.id === 'hull')];
        let opts = [...available].sort(() => 0.5 - Math.random()).slice(0, 3);
        opts.forEach(u => {
            let el = document.createElement('div'); el.className = 'card';
            el.innerHTML = `<div class='rarity'></div><h3>${u.name}</h3><p>${u.desc}</p><span class='limit-tag'>OWNED: ${u.count} / ${u.max >= 99 ? '‚àû' : u.max}</span>`;
            el.onclick = () => {
                u.count++;
                if (u.type === 'stat') { if (u.key === 'fireRate') player.fireRate *= u.val; else if (u.key === 'bulletCount') player.bulletCount += u.val; else player[u.key] *= u.val; }
                else if (u.type === 'heal') { player.maxHp += 50; player.hp = Math.min(player.maxHp, player.maxHp + 50); }
                else { if (u.key === 'orbital') player.orbitals++; if (u.key === 'meteor') { player.meteorLevel++; player.lastMeteor = 0; } if (u.key === 'laser') { player.laserLevel++; player.lastLaser = frame; } if (u.key === 'mine') player.mineLevel++; }
                menu.style.display = 'none'; isPaused = false; updateUI();
            };
            container.appendChild(el);
        });
    }

    // --- MAIN LOOP ---
    function loop() {
        if (gameActive && !isPaused) {
            // movement (keyboard + joystick)
            let dx = 0, dy = 0;
            if (keys['KeyW'] || keys['ArrowUp']) dy = -1;
            if (keys['KeyS'] || keys['ArrowDown']) dy = 1;
            if (keys['KeyA'] || keys['ArrowLeft']) dx = -1;
            if (keys['KeyD'] || keys['ArrowRight']) dx = 1;
            if (joystick.active && (Math.abs(joystick.dx) > 0.01 || Math.abs(joystick.dy) > 0.01)) { dx = joystick.dx; dy = joystick.dy; }
            let moving = (dx !== 0 || dy !== 0);
            if (moving) {
                let len = Math.hypot(dx, dy) || 1;
                player.x += (dx/len) * player.speed;
                player.y += (dy/len) * player.speed;
                // generate trail
                if (frame % 5 === 0 && equipped.trail !== 'trail_none') {
                    let tColor = '#fff', tSize = 4, tLife = 1;
                    if (equipped.trail === 'trail_rain') tColor = `hsl(${frame%360}, 100%, 50%)`;
                    else if (equipped.trail === 'trail_smoke') { tColor = 'rgba(100,100,100,0.5)'; tSize = 8; tLife = 1.5; }
                    else if (equipped.trail === 'trail_pixie') { tColor = '#fff'; tSize = 2; }
                    else if (equipped.trail === 'trail_bub') { tColor = 'rgba(0, 100, 255, 0.4)'; tSize = 6; }
                    else if (equipped.trail === 'trail_electro') { tColor = '#66ffcc'; tSize = 5; tLife = 1.2; }
                    trailParticles.push({ x: player.x, y: player.y, color: tColor, size: tSize, life: tLife, type: equipped.trail });
                }
            }

            player.regenTimer++;
            if (player.regenTimer >= 60 && player.hp < player.maxHp) { player.hp = Math.min(player.maxHp, player.hp + 1); player.regenTimer = 0; updateUI(); }
            if (player.invulnTimer > 0) player.invulnTimer--;

            // Shooting / abilities
            if (frame % Math.floor(player.fireRate) === 0) shoot();
            if (player.laserLevel > 0 && frame - player.lastLaser > 600) { fireLaser(); player.lastLaser = frame; }
            if (player.mineLevel > 0) {
                let mineCd = Math.max(90, 300 - (player.mineLevel * 40));
                if (frame - player.lastMine > mineCd) { dropMine(); player.lastMine = frame; }
            }
            if (player.meteorLevel > 0) {
                let delay = 5000 / player.meteorLevel;
                if (Date.now() - player.lastMeteor > delay) { triggerMeteor(); player.lastMeteor = Date.now(); }
            }

            updateEntities();
            globalDifficulty = 1 + (frame / 2000);

            let seconds = Math.floor(frame / 60);
            let mins = Math.floor(seconds / 60);
            let secs = seconds % 60;
            document.getElementById('time-text').innerText = (mins<10?"0":"")+mins + ":" + (secs<10?"0":"")+secs;

            // Camera centers on player
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;

            draw();
            frame++;
        } else if (isDying) {
            drawDeathAnim();
            frame++;
        }
        requestAnimationFrame(loop);
    }

    // --- UI helpers ---
    function updateUI() {
        document.getElementById('score-text').innerText = "KILLS: " + player.score;
        document.getElementById('level-text').innerText = "LVL: " + player.level;
        document.getElementById('xp-bar-fill').style.width = (player.xp / player.nextXp * 100) + "%";
        document.getElementById('hp-bar-fill').style.width = Math.max(0, (player.hp / player.maxHp) * 100) + "%";
        document.getElementById('hp-text').innerText = Math.ceil(player.hp) + " / " + player.maxHp;

        if (player.laserLevel > 0) {
            let slot = document.getElementById('slot-laser'); slot.style.display = 'flex';
            let pct = Math.min(1, (frame - player.lastLaser) / 600);
            document.getElementById('fill-laser').style.height = (pct*100) + "%";
            slot.classList.toggle('ready', pct >= 1);
        }
        if (player.mineLevel > 0) {
            let slot = document.getElementById('slot-mine'); slot.style.display = 'flex';
            let cd = Math.max(90, 300 - (player.mineLevel * 40));
            let pct = Math.min(1, (frame - player.lastMine) / cd);
            document.getElementById('fill-mine').style.height = (pct*100) + "%";
            slot.classList.toggle('ready', pct >= 1);
        }
        const cc = document.getElementById('coin-count'); if (cc) cc.innerText = totalCoins;
    }

    // Expose functions to window
    window.startGame = startGame;
    window.openShop = () => { document.getElementById('start-screen').style.display = 'none'; document.getElementById('shop-screen').style.display = 'flex'; renderShop(); };
    window.closeShop = () => { document.getElementById('shop-screen').style.display = 'none'; document.getElementById('start-screen').style.display = 'flex'; };
    window.showLeaderboard = async () => {
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('death-screen').style.display = 'none';
        document.getElementById('leaderboard-screen').style.display = 'flex';
        let content = document.getElementById('leaderboard-content');
        content.innerHTML = "LOADING DATA...";
        let data = await getLeaderboardFromCloud();
        content.innerHTML = "";
        if (!data || data.length === 0) { content.innerHTML = "<p style='color:#666; margin-top:50px;'>NO CLOUD DATA OR OFFLINE.</p>"; return; }

        // Render entries with highlights:
        data.forEach((entry, i) => {
            const div = document.createElement('div');
            div.className = 'lb-row';
            if (i === 0) div.classList.add('gold');
            else if (i === 1) div.classList.add('silver');
            else if (i === 2) div.classList.add('bronze');

            const entryName = (entry.name || '').toString();
            if (entryName && playerName && entryName.toUpperCase() === playerName.toUpperCase()) {
                div.classList.add('lb-highlight');
            }
            // Highlight assistant name (copilot) in blue as well
            if (entryName.toLowerCase().includes('copilot') || entryName.toLowerCase() === '@copilot') {
                div.classList.add('lb-highlight');
            }

            div.innerHTML = `<span>#${i+1} ${entryName}</span><span>${entry.score}</span>`;
            content.appendChild(div);
        });
    };
    window.hideLeaderboard = () => { document.getElementById('leaderboard-screen').style.display = 'none'; document.getElementById('start-screen').style.display = 'flex'; };
    window.updateName = (v) => updateName(v);
    window.restartGame = restartGame;

    // DOM ready init
    document.addEventListener('DOMContentLoaded', async () => {
        await initFirebase();
        loadData();
        setupJoystick();
        resetUpgrades();

        // wire buttons
        const btnStart = document.getElementById('btn-start');
        const btnShop = document.getElementById('btn-shop');
        const btnLeaderboard = document.getElementById('btn-leaderboard');
        const btnShopBack = document.getElementById('btn-shop-back');
        const btnLbBack = document.getElementById('btn-leaderboard-back');
        const btnReboot = document.getElementById('btn-reboot');
        const btnMain = document.getElementById('btn-mainmenu');
        const nameInput = document.getElementById('player-name');

        if (nameInput) { nameInput.value = playerName; nameInput.addEventListener('input', (e) => updateName(e.target.value)); }
        if (btnStart) btnStart.addEventListener('click', () => startGame());
        if (btnShop) btnShop.addEventListener('click', () => window.openShop());
        if (btnLeaderboard) btnLeaderboard.addEventListener('click', () => window.showLeaderboard());
        if (btnShopBack) btnShopBack.addEventListener('click', () => window.closeShop());
        if (btnLbBack) btnLbBack.addEventListener('click', () => window.hideLeaderboard());
        if (btnReboot) btnReboot.addEventListener('click', () => restartGame());
        if (btnMain) btnMain.addEventListener('click', () => location.reload());

        // ensure UI layer shows at start only when game launched
        document.getElementById('ui-layer').style.display = 'none';

        // place player near world origin and start the animation loop
        player.x = 0; player.y = 0;
        requestAnimationFrame(loop);
    });

    </script>
</body>
</html>
