<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Swarm: MEGA SHOP</title>
    <style>
        /* CORE STYLES */
        body { margin: 0; overflow: hidden; background: #050505; color: white; font-family: 'Courier New', Courier, monospace; user-select: none; touch-action: none; }
        canvas { display: block; }
        
        /* UI LAYERS */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }
        .hud-top { position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-between; padding: 0 40px; box-sizing: border-box; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px var(--hud-shadow, #0088ff); color: var(--hud-color, #00ffff); }
        .hud-bottom { position: absolute; bottom: 20px; width: 100%; padding: 0 40px; box-sizing: border-box; display: flex; gap: 20px; align-items: flex-end; }
        
        /* BARS */
        .bar-container { width: 300px; height: 20px; background: rgba(0,0,0,0.5); border: 2px solid #333; position: relative; }
        .bar-fill { height: 100%; width: 0%; transition: width 0.2s; }
        #xp-bar-fill { background: #ffd700; box-shadow: 0 0 10px #ffd700; }
        #hp-bar-fill { background: #ff0055; box-shadow: 0 0 10px #ff0055; width: 100%; }
        .bar-text { position: absolute; top: -25px; left: 0; color: #fff; font-size: 14px; }

        /* ABILITY SLOTS */
        .ability-dock { display: flex; gap: 15px; margin-left: auto; }
        .ability-slot { width: 50px; height: 50px; border: 2px solid #333; background: rgba(0,0,0,0.8); position: relative; display: none; align-items: center; justify-content: center; font-size: 20px; color: #555; }
        .ability-fill { position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(0, 255, 255, 0.3); height: 0%; transition: height 0.1s linear; }
        .ability-slot.ready { border-color: #00ffff; color: #00ffff; box-shadow: 0 0 15px #00ffff; }

        /* MENUS & SCREENS */
        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; backdrop-filter: blur(5px); }
        h1 { font-size: 80px; margin: 0; text-shadow: 0 0 20px #00ffff; color: #fff; letter-spacing: 5px; text-align: center; }
        
        /* NEW BUTTON LAYOUT */
        .menu-row { display: flex; align-items: center; gap: 30px; margin-top: 30px; }
        
        button { background: transparent; border: 2px solid #555; color: #aaa; padding: 15px 30px; font-size: 20px; font-family: inherit; cursor: pointer; transition: 0.2s; text-transform: uppercase; letter-spacing: 2px; }
        button:hover { border-color: #00ffff; color: #00ffff; box-shadow: 0 0 15px rgba(0,255,255,0.3); }
        button:disabled { border-color: #333; color: #333; box-shadow: none; cursor: not-allowed; opacity: 0.5; }
        
        .btn-main { border: 2px solid #00ffff; color: #00ffff; font-size: 32px; padding: 20px 60px; font-weight: bold; background: rgba(0, 255, 255, 0.05); }
        .btn-main:hover:not(:disabled) { background: #00ffff; color: #000; box-shadow: 0 0 30px #00ffff; transform: scale(1.05); }

        input { background: transparent; border: none; border-bottom: 2px solid #555; color: #fff; font-family: inherit; font-size: 30px; text-align: center; margin: 20px; width: 350px; outline: none; text-transform: uppercase; }
        input:focus { border-color: #00ffff; }
        
        #name-error { color: #ff0055; font-weight: bold; display: none; margin-top: -10px; margin-bottom: 10px; text-shadow: 0 0 10px red; }

        /* SHOP */
        #shop-content { display: flex; flex-direction: column; gap: 10px; width: 70%; max-height: 60vh; overflow-y: auto; background: rgba(0,0,0,0.5); padding: 20px; border: 1px solid #333; }
        .shop-row { display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.05); padding: 10px; border: 1px solid #333; }
        .shop-info { display: flex; align-items: center; gap: 15px; }
        .shop-preview { width: 40px; height: 40px; border: 2px solid #555; display: flex; align-items: center; justify-content: center; font-size: 20px; }
        .buy-btn { font-size: 14px; padding: 5px 15px; margin: 0; min-width: 100px; }
        .buy-btn.equipped { background: #00ff00; border-color: #00ff00; color: #000; pointer-events: none; }
        .buy-btn:disabled { border-color: #555; color: #555; cursor: not-allowed; }

        /* CARDS & LEADERBOARD */
        #upgrade-menu { display: none; }
        #cards { display: flex; gap: 20px; margin-top: 40px; flex-wrap: wrap; justify-content: center; }
        .card { width: 220px; height: 320px; background: #111; border: 2px solid #444; padding: 20px; display: flex; flex-direction: column; align-items: center; text-align: center; cursor: pointer; transition: 0.3s; position: relative; overflow: hidden; }
        .card:hover { transform: translateY(-10px); border-color: #fff; box-shadow: 0 0 30px rgba(255,255,255,0.2); }
        .card h3 { color: #ffd700; margin: 10px 0; font-size: 22px; }
        .card p { color: #aaa; font-size: 14px; line-height: 1.4; }
        .rarity { width: 100%; height: 5px; background: #444; position: absolute; top: 0; left: 0; }

        #leaderboard-content { width: 500px; max-height: 60vh; overflow-y: auto; border: 1px solid #333; padding: 20px; background: rgba(0,0,0,0.8); }
        .lb-row { display: flex; justify-content: space-between; padding: 10px; border-bottom: 1px solid #222; font-size: 18px; color: #aaa; }
        .lb-row.top { color: #ffd700; font-weight: bold; font-size: 22px; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
        
        #coin-anim { position: absolute; top: 80px; left: 60px; color: #ffd700; font-size: 20px; font-weight: bold; opacity: 0; transition: 0.5s; pointer-events: none; }

        /* JOYSTICK STYLE */
        #joystick-zone { position: absolute; bottom: 50px; left: 50px; width: 150px; height: 150px; border: 2px solid rgba(255,255,255,0.1); border-radius: 50%; display: none; pointer-events: none; z-index: 100; }
        #joystick-knob { width: 60px; height: 60px; background: rgba(0, 255, 255, 0.5); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 20px #00ffff; }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="joystick-zone"><div id="joystick-knob"></div></div>

    <div id="ui-layer">
        <div class="hud-top">
            <span id="score-text">KILLS: 0</span>
            <span id="time-text">00:00</span>
            <span id="level-text">LVL: 1</span>
        </div>
        <div id="coin-anim">+1 ðŸª™</div>
        <div class="hud-bottom">
            <div class="bar-container">
                <span class="bar-text" id="hp-text">100 / 100</span>
                <div class="bar-fill" id="hp-bar-fill"></div>
            </div>
            <div class="bar-container" style="width: 100%; height: 10px; border-color: #444;">
                <div class="bar-fill" id="xp-bar-fill"></div>
            </div>
            <div class="ability-dock">
                <div class="ability-slot" id="slot-laser">L<div class="ability-fill" id="fill-laser"></div></div>
                <div class="ability-slot" id="slot-mine">M<div class="ability-fill" id="fill-mine"></div></div>
            </div>
        </div>
    </div>

    <div id="start-screen" class="screen">
        <h1>NEON SWARM</h1>
        <p style="color: #888; letter-spacing: 2px; margin-bottom: 20px;">WASD / TOUCH to Move</p>
        
        <input type="text" id="player-name" placeholder="ENTER NAME" maxlength="15" oninput="updateName(this.value)">
        <div id="name-error">INVALID NAME: CONTAINS BANNED WORDS</div>
        
        <div class="menu-row">
            <button onclick="showLeaderboard()">RANKINGS</button>
            
            <button class="btn-main" id="btn-start" onclick="startGame()">START</button>
            
            <button onclick="openShop()">SHOP (<span id="coin-count">0</span> ðŸª™)</button>
        </div>
    </div>

    <div id="shop-screen" class="screen" style="display:none;">
        <h2>ARMORY</h2>
        <div style="margin-bottom: 15px; color:#ffd700;">BALANCE: <span id="shop-coins">0</span> ðŸª™</div>
        <div id="shop-content"></div>
        <button onclick="closeShop()" style="margin-top: 20px;">BACK</button>
    </div>

    <div id="leaderboard-screen" class="screen" style="display:none;">
        <h2>GLOBAL RANKINGS</h2>
        <div id="leaderboard-content">LOADING...</div>
        <button onclick="hideLeaderboard()" style="margin-top: 20px;">BACK</button>
    </div>

    <div id="upgrade-menu" class="screen" style="background: rgba(0,0,0,0.9);">
        <h2 style="color: #fff; text-shadow: none;">SYSTEM UPGRADE</h2>
        <div id="cards"></div>
    </div>

    <div id="death-screen" class="screen" style="display:none;">
        <h1 style="color: #ff0055; text-shadow: 0 0 30px #ff0055;">CRITICAL FAILURE</h1>
        <p id="final-stats" style="font-size: 24px; margin-top: 20px; color: #fff;"></p>
        <p style="color: #888; font-size: 14px; margin-top: 10px;">SCORE SAVED TO CLOUD</p>
        <div style="display:flex; gap:20px;">
            <button onclick="restartGame()">RETRY</button>
            <button onclick="location.reload()">MENU</button>
        </div>
    </div>

    <script type="module">
        // --- FIREBASE SETUP ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs, where, updateDoc, doc } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

        // YOUR CONFIG
        const firebaseConfig = {
            apiKey: "AIzaSyD6rmIdWG1pm695Q_0Zcapbwcx8JlvgpHY",
            authDomain: "neon-swarm.firebaseapp.com",
            projectId: "neon-swarm",
            storageBucket: "neon-swarm.firebasestorage.app",
            messagingSenderId: "982908895215",
            appId: "1:982908895215:web:379252fdb7138262bec01a",
            measurementId: "G-XGFTTFLM4K"
        };

        let db;
        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            console.log("Firebase Connected Successfully");
        } catch(e) {
            console.error("Firebase connection failed:", e);
        }

        // --- PROFANITY FILTER ---
        // Add words here you want to block. MUST BE UPPERCASE HERE.
        const bannedWords = ["NIG", "RAPE", "FUCK", "SHIT", "BITCH", "JEW"]; 

        // --- CLOUD FUNCTIONS ---
        async function saveScoreToCloud(userId, name, score) {
            if(!db) return;
            try {
                const q = query(collection(db, "leaderboard"), where("uid", "==", userId));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    querySnapshot.forEach(async (docSnap) => {
                        const oldScore = docSnap.data().score;
                        if (score > oldScore) {
                            await updateDoc(doc(db, "leaderboard", docSnap.id), { score: score, name: name, date: Date.now() });
                            console.log("Updated High Score & Name");
                        } else {
                            await updateDoc(doc(db, "leaderboard", docSnap.id), { name: name });
                            console.log("Updated Name Only");
                        }
                    });
                } else {
                    await addDoc(collection(db, "leaderboard"), { uid: userId, name: name, score: score, date: Date.now() });
                    console.log("Created New Score Entry");
                }
            } catch (e) { console.error("Error saving score: ", e); }
        }

        async function getLeaderboardFromCloud() {
            if(!db) return [];
            try {
                const q = query(collection(db, "leaderboard"), orderBy("score", "desc"), limit(10));
                const querySnapshot = await getDocs(q);
                let results = [];
                querySnapshot.forEach((doc) => { results.push(doc.data()); });
                return results;
            } catch (e) { return []; }
        }

        // --- GAME ENGINE ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const root = document.documentElement;
        
        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        window.addEventListener('resize', resize);
        resize();

        // --- JOYSTICK LOGIC ---
        let touchStart = { x: 0, y: 0 };
        let touchCurrent = { x: 0, y: 0 };
        let isTouching = false;
        const joyZone = document.getElementById('joystick-zone');
        const joyKnob = document.getElementById('joystick-knob');

        window.addEventListener('touchstart', e => {
            if (!gameActive || isPaused) return;
            if (e.target.tagName === 'BUTTON') return;
            
            let touch = e.touches[0];
            touchStart = { x: touch.clientX, y: touch.clientY };
            touchCurrent = { x: touch.clientX, y: touch.clientY };
            isTouching = true;
            
            joyZone.style.display = 'block';
            joyZone.style.left = (touchStart.x - 75) + 'px';
            joyZone.style.top = (touchStart.y - 75) + 'px';
            joyKnob.style.transform = `translate(-50%, -50%)`;
        });

        window.addEventListener('touchmove', e => {
            if (!isTouching) return;
            e.preventDefault(); 
            let touch = e.touches[0];
            touchCurrent = { x: touch.clientX, y: touch.clientY };

            let dx = touchCurrent.x - touchStart.x;
            let dy = touchCurrent.y - touchStart.y;
            let dist = Math.hypot(dx, dy);
            let maxDist = 40;
            if (dist > maxDist) { dx = (dx/dist)*maxDist; dy = (dy/dist)*maxDist; }
            joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        });

        window.addEventListener('touchend', () => {
            isTouching = false;
            joyZone.style.display = 'none';
        });

        // --- GAME DATA ---
        let gameActive = false;
        let isPaused = false;
        let isDying = false; 
        let deathTimer = 0;
        let frame = 0;
        let camera = { x: 0, y: 0 };
        let globalDifficulty = 1;
        
        let totalCoins = 0;
        let playerName = "";
        let playerUid = "";
        let inventory = ['skin_default', 'bg_default', 'proj_orb', 'trail_none', 'ui_default', 'death_default']; 
        let equipped = {
            skin: 'skin_default', bg: 'bg_default', proj: 'proj_orb', trail: 'trail_none', ui: 'ui_default', death: 'death_default'
        };

        let player = { x: 0, y: 0, hp: 100, maxHp: 100, regenTimer: 0, invulnTimer: 0, speed: 5, size: 15, level: 1, xp: 0, nextXp: 50, score: 0, fireRate: 25, bulletDmg: 20, bulletSpeed: 12, bulletCount: 1, pierce: 0, pickupRange: 150, orbitals: 0 };

        let bullets = [], enemies = [], particles = [], gems = [], damageText = [], trailParticles = [];
        const keys = {};
        window.addEventListener('keydown', e => { keys[e.key] = true; keys[e.code] = true; });
        window.addEventListener('keyup', e => { keys[e.key] = false; keys[e.code] = false; });

        // --- RESTOCKED SHOP ---
        const cosmetics = [
            // SKINS
            { id: 'skin_default', type: 'skin', name: 'NEON CYAN', color: '#00ffff', cost: 0 },
            { id: 'skin_red', type: 'skin', name: 'CRIMSON FURY', color: '#ff0000', cost: 20 },
            { id: 'skin_gold', type: 'skin', name: 'MIDAS TOUCH', color: '#ffd700', cost: 50 },
            { id: 'skin_lime', type: 'skin', name: 'TOXIC LIME', color: '#39ff14', cost: 30 },
            { id: 'skin_pink', type: 'skin', name: 'HOT PINK', color: '#ff00ff', cost: 30 },
            { id: 'skin_ghost', type: 'skin', name: 'GHOST WHITE', color: '#ffffff', cost: 40 },
            
            // BACKGROUNDS
            { id: 'bg_default', type: 'bg', name: 'DEEP SPACE', bg: '#050505', grid: '#222', cost: 0 },
            { id: 'bg_matrix', type: 'bg', name: 'THE MATRIX', bg: '#001100', grid: '#004400', cost: 30 },
            { id: 'bg_cyber', type: 'bg', name: 'CYBER GRID', bg: '#0f0014', grid: '#550055', cost: 40 },
            { id: 'bg_blue', type: 'bg', name: 'BLUEPRINT', bg: '#000514', grid: '#002266', cost: 40 },
            
            // PROJECTILES
            { id: 'proj_orb', type: 'proj', name: 'PLASMA ORB', symbol: '', color: '#ffff00', cost: 0 },
            { id: 'proj_star', type: 'proj', name: 'STAR POWER', symbol: 'â˜…', color: '#ffaa00', cost: 50 },
            { id: 'proj_heart', type: 'proj', name: 'LOVE RAY', symbol: 'â™¥', color: '#ff0055', cost: 40 },
            { id: 'proj_note', type: 'proj', name: 'BASS CANNON', symbol: 'â™ª', color: '#00ffff', cost: 40 },
            { id: 'proj_shuri', type: 'proj', name: 'NINJA STAR', symbol: 'âœ¦', color: '#ffffff', cost: 60 },
            
            // TRAILS
            { id: 'trail_none', type: 'trail', name: 'NO TRAIL', color: 'transparent', cost: 0 },
            { id: 'trail_rain', type: 'trail', name: 'RAINBOW', color: 'rainbow', cost: 60 },
            { id: 'trail_fire', type: 'trail', name: 'AFTERBURNER', color: 'fire', cost: 40 },
            { id: 'trail_plasma', type: 'trail', name: 'PLASMA LEAK', color: 'plasma', cost: 40 },
            
            // UI
            { id: 'ui_default', type: 'ui', name: 'DEFAULT CYAN', hud: '#00ffff', shadow: '#0088ff', cost: 0 },
            { id: 'ui_gold', type: 'ui', name: 'LUXURY GOLD', hud: '#ffd700', shadow: '#aa7700', cost: 60 },
            { id: 'ui_red', type: 'ui', name: 'DANGER RED', hud: '#ff0000', shadow: '#880000', cost: 40 },
            
            // DEATH
            { id: 'death_default', type: 'death', name: 'STANDARD', cost: 0 },
            { id: 'death_conf', type: 'death', name: 'CONFETTI', cost: 50 }
        ];

        // --- SAVE / LOAD SYSTEM ---
        function loadData() {
            let saved = localStorage.getItem('neon_swarm_data_v3');
            if (saved) {
                let data = JSON.parse(saved);
                totalCoins = data.coins || 0;
                playerName = data.name || "";
                inventory = data.inventory || inventory;
                playerUid = data.uid || "user_" + Date.now() + "_" + Math.floor(Math.random()*10000);
                if(data.equipped) equipped = { ...equipped, ...data.equipped };
            } else {
                playerUid = "user_" + Date.now() + "_" + Math.floor(Math.random()*10000);
            }
            if (!playerName || playerName.trim() === "") {
                playerName = "GUEST" + Math.floor(1000 + Math.random() * 9000);
            }
            applyTheme();
            document.getElementById('coin-count').innerText = totalCoins;
            document.getElementById('player-name').value = playerName;
        }

        function saveData() {
            let data = { coins: totalCoins, name: playerName, inventory: inventory, equipped: equipped, uid: playerUid };
            localStorage.setItem('neon_swarm_data_v3', JSON.stringify(data));
        }
        
        function updateName(val) { 
            let upper = val.toUpperCase();
            let invalid = false;
            bannedWords.forEach(w => { if(upper.includes(w)) invalid = true; });

            const btn = document.getElementById('btn-start');
            const err = document.getElementById('name-error');

            if(invalid) {
                btn.disabled = true;
                err.style.display = 'block';
            } else {
                btn.disabled = false;
                err.style.display = 'none';
                playerName = upper; 
                saveData(); 
            }
        }
        
        function applyTheme() {
            let ui = cosmetics.find(c => c.id === equipped.ui) || cosmetics.find(c => c.id === 'ui_default');
            root.style.setProperty('--hud-color', ui.hud);
            root.style.setProperty('--hud-shadow', ui.shadow);
            document.getElementById('level-text').style.color = ui.hud;
        }

        loadData();

        // --- SHOP LOGIC ---
        function openShop() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('death-screen').style.display = 'none';
            document.getElementById('shop-screen').style.display = 'flex';
            renderShop();
        }

        function closeShop() {
            document.getElementById('shop-screen').style.display = 'none';
            document.getElementById('start-screen').style.display = 'flex';
        }

        function renderShop() {
            document.getElementById('shop-coins').innerText = totalCoins;
            let content = document.getElementById('shop-content');
            content.innerHTML = '';
            
            let categories = [
                { id: 'skin', name: 'SHIP SKINS' },
                { id: 'bg', name: 'BACKGROUNDS' },
                { id: 'proj', name: 'PROJECTILES' },
                { id: 'trail', name: 'ENGINE TRAILS' },
                { id: 'ui', name: 'HUD THEMES' },
                { id: 'death', name: 'DEATH FX' }
            ];

            categories.forEach(cat => {
                let title = document.createElement('div'); 
                title.style.color = '#888'; title.style.marginTop='15px'; title.innerText = cat.name; 
                content.appendChild(title);
                
                cosmetics.filter(c => c.type === cat.id).forEach(item => {
                    let row = document.createElement('div');
                    row.className = 'shop-row';
                    let owned = inventory.includes(item.id);
                    let isEquipped = equipped[cat.id] === item.id;
                    let btnText = isEquipped ? "EQUIPPED" : (owned ? "EQUIP" : "BUY " + item.cost + "ðŸª™");
                    let btnClass = isEquipped ? "buy-btn equipped" : (owned ? "buy-btn" : (totalCoins >= item.cost ? "buy-btn can-buy" : "buy-btn"));
                    
                    row.innerHTML = `
                        <div class="shop-info">
                            <div><h3 style="margin:0; font-size:16px; color:#fff">${item.name}</h3></div>
                        </div>
                        <button class="${btnClass}" ${(!owned && totalCoins < item.cost) ? 'disabled' : ''}>${btnText}</button>
                    `;
                    row.querySelector('button').onclick = () => handleShopClick(item, cat.id);
                    content.appendChild(row);
                });
            });
        }

        function handleShopClick(item, type) {
            if (inventory.includes(item.id)) {
                equipped[type] = item.id;
            } else {
                if (totalCoins >= item.cost) {
                    totalCoins -= item.cost; inventory.push(item.id);
                    equipped[type] = item.id;
                }
            }
            if(type === 'ui') applyTheme();
            saveData(); renderShop(); document.getElementById('coin-count').innerText = totalCoins;
        }

        // --- LEADERBOARD & ENGINE SETUP ---
        async function showLeaderboard() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('death-screen').style.display = 'none';
            document.getElementById('leaderboard-screen').style.display = 'flex';
            let content = document.getElementById('leaderboard-content');
            content.innerHTML = "LOADING DATA...";
            
            let data = await getLeaderboardFromCloud();
            
            content.innerHTML = "";
            if (data.length === 0) { content.innerHTML = "<p style='color:#666; margin-top:50px;'>NO CLOUD DATA OR OFFLINE.</p>"; return; }
            
            data.forEach((entry, i) => {
                content.innerHTML += `<div class="lb-row ${i===0?'top':''}"><span>#${i+1} ${entry.name}</span><span>${entry.score}</span></div>`;
            });
        }
        
        function hideLeaderboard() {
            document.getElementById('leaderboard-screen').style.display = 'none';
            document.getElementById('start-screen').style.display = 'flex';
        }

        let upgradePool = [];
        function resetUpgrades() {
            upgradePool = [
                { id: "fire", name: "RAPID FIRE", desc: "Fire Rate +15%", type: "stat", key: "fireRate", val: 0.85, max: 8, count: 0 },
                { id: "multi", name: "MULTISHOT", desc: "+1 Projectile", type: "stat", key: "bulletCount", val: 1, max: 6, count: 0 },
                { id: "dmg", name: "HIGH CALIBER", desc: "Damage +30%", type: "stat", key: "bulletDmg", val: 1.3, max: 10, count: 0 },
                { id: "speed", name: "THRUSTERS", desc: "Move Speed +10%", type: "stat", key: "speed", val: 1.10, max: 5, count: 0 },
                { id: "mag", name: "MAGNET FIELD", desc: "Pickup Range +40%", type: "stat", key: "pickupRange", val: 1.4, max: 5, count: 0 },
                { id: "orb", name: "PLASMA ORBITAL", desc: "Add spinning shield", type: "ability", key: "orbital", max: 5, count: 0 },
                { id: "hull", name: "TITANIUM HULL", desc: "+50 Max HP & Heal", type: "heal", max: 99, count: 0 }
            ];
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';
            restartGame();
        }

        function restartGame() {
            gameActive = true; isPaused = false; isDying = false; frame = 0; globalDifficulty = 1;
            player = {
                x: 0, y: 0, hp: 100, maxHp: 100, regenTimer: 0, invulnTimer: 0,
                speed: 5, size: 15, level: 1, xp: 0, nextXp: 50, score: 0,
                fireRate: 25, bulletDmg: 20, bulletSpeed: 12, bulletCount: 1, pierce: 0, pickupRange: 150,
                orbitals: 0
            };
            resetUpgrades();
            bullets = []; enemies = []; particles = []; gems = []; damageText = []; trailParticles = [];
            document.getElementById('death-screen').style.display = 'none';
            document.getElementById('upgrade-menu').style.display = 'none';
            updateUI();
        }

        function loop() {
            if (gameActive && !isPaused) { update(); draw(); frame++; }
            else if (isDying) { drawDeathAnim(); }
            requestAnimationFrame(loop);
        }

        function update() {
            globalDifficulty = 1 + (frame / 2000); 
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;

            // MOVEMENT
            let dx = 0, dy = 0;
            if (isTouching) {
                dx = (touchCurrent.x - touchStart.x) / 40; 
                dy = (touchCurrent.y - touchStart.y) / 40;
                if (Math.hypot(dx, dy) > 1) {
                    let angle = Math.atan2(dy, dx);
                    dx = Math.cos(angle); dy = Math.sin(angle);
                }
            } else {
                if (keys['KeyW'] || keys['ArrowUp']) dy = -1;
                if (keys['KeyS'] || keys['ArrowDown']) dy = 1;
                if (keys['KeyA'] || keys['ArrowLeft']) dx = -1;
                if (keys['KeyD'] || keys['ArrowRight']) dx = 1;
            }
            
            let moving = (dx !== 0 || dy !== 0);
            if (moving) {
                let len = Math.hypot(dx, dy);
                if (len > 0.1) {
                     player.x += (dx/len) * player.speed;
                     player.y += (dy/len) * player.speed;
                }
            }

            // TRAIL
            if (moving && frame % 5 === 0 && equipped.trail !== 'trail_none') {
                let tColor = '#fff';
                if (equipped.trail === 'trail_rain') tColor = `hsl(${frame%360}, 100%, 50%)`;
                if (equipped.trail === 'trail_fire') tColor = `hsl(${0 + Math.random()*40}, 100%, 50%)`;
                if (equipped.trail === 'trail_plasma') tColor = `hsl(${180 + Math.random()*40}, 100%, 50%)`;
                trailParticles.push({ x: player.x, y: player.y, color: tColor, size: 4, life: 1, type: equipped.trail });
            }

            // REGEN
            player.regenTimer++;
            if (player.regenTimer >= 60 && player.hp < player.maxHp) {
                player.hp = Math.min(player.maxHp, player.hp + 1); player.regenTimer = 0; updateUI();
            }
            if (player.invulnTimer > 0) player.invulnTimer--;

            // SHOOTING
            if (frame % Math.floor(player.fireRate) === 0) shoot();
            
            updateEntities();
            
            let seconds = Math.floor(frame / 60);
            document.getElementById('time-text').innerText = Math.floor(seconds/60) + ":" + (seconds%60 < 10 ? "0" : "") + (seconds%60);
            updateUI(); 
        }

        function updateEntities() {
            // TRAIL
            for(let i=trailParticles.length-1; i>=0; i--) {
                let p = trailParticles[i]; p.life -= 0.02; 
                if(p.life <= 0) trailParticles.splice(i, 1);
            }

            // BULLETS
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                b.x += Math.cos(b.angle) * player.bulletSpeed;
                b.y += Math.sin(b.angle) * player.bulletSpeed;
                b.life--;
                let hit = false;
                for (let e of enemies) {
                    if (Math.hypot(b.x - e.x, b.y - e.y) < e.size + b.size) {
                        damageEnemy(e, player.bulletDmg);
                        b.hits++; if (b.hits > player.pierce) hit = true; break; 
                    }
                }
                if (hit || b.life <= 0) bullets.splice(i, 1);
            }

            // ENEMIES
            let spawnRate = Math.max(1, 40 - (player.level*1.5 + (frame/600))); 
            if (frame % Math.floor(spawnRate) === 0) spawnEnemy();

            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                let angle = Math.atan2(player.y - e.y, player.x - e.x);
                e.x += Math.cos(angle) * e.speed;
                e.y += Math.sin(angle) * e.speed;

                if (player.orbitals > 0) {
                    let dist = Math.hypot(player.x - e.x, player.y - e.y);
                    if (dist < 100 && frame % 10 === 0) { damageEnemy(e, player.bulletDmg * 0.8); }
                }
                let dist = Math.hypot(player.x - e.x, player.y - e.y);
                if (dist < player.size + e.size) { takeDamage(10); }
                if (dist > 2500) enemies.splice(i, 1);
            }

            // GEMS
            for (let i = gems.length - 1; i >= 0; i--) {
                let g = gems[i];
                let dist = Math.hypot(player.x - g.x, player.y - g.y);
                if (dist < player.pickupRange) g.mag = true;
                if (g.mag) {
                    let angle = Math.atan2(player.y - g.y, player.x - g.x);
                    g.x += Math.cos(angle) * (player.speed + 8);
                    g.y += Math.sin(angle) * (player.speed + 8);
                    if (dist < player.size + 10) { gainXp(g.val); gems.splice(i, 1); }
                }
            }
            particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life -= 0.05; if(p.life <= 0) particles.splice(i,1); });
            damageText.forEach((d, i) => { d.y -= 1; d.life -= 0.02; if(d.life <= 0) damageText.splice(i,1); });
        }

        function spawnEnemy() {
            let angle = Math.random() * Math.PI * 2;
            let dist = (Math.max(canvas.width, canvas.height) / 2) + 100;
            let x = player.x + Math.cos(angle) * dist;
            let y = player.y + Math.sin(angle) * dist;
            enemies.push({ x, y, type: 'grunt', size: 20, hp: 20 * globalDifficulty, speed: 2 + (globalDifficulty*0.2), color: '#ff0055' });
        }

        function damageEnemy(e, amt) {
            e.hp -= amt;
            damageText.push({ x: e.x, y: e.y, val: Math.floor(amt), life: 1 });
            if (e.hp <= 0 && enemies.includes(e)) {
                enemies.splice(enemies.indexOf(e), 1);
                player.score++;
                if (player.score % 10 === 0) {
                    totalCoins++; saveData(); document.getElementById('coin-count').innerText = totalCoins;
                }
                gems.push({ x: e.x, y: e.y, val: 5 + Math.floor(globalDifficulty), mag: false });
                updateUI();
            }
        }

        function shoot() {
            let targets = enemies.map(e => ({ e: e, dist: Math.hypot(player.x - e.x, player.y - e.y) })).filter(i => i.dist < 650).sort((a,b)=>a.dist-b.dist);
            if (targets.length === 0) return;
            for (let i = 0; i < player.bulletCount; i++) {
                let target = targets[i % targets.length].e;
                let angle = Math.atan2(target.y - player.y, target.x - player.x) + (Math.random() - 0.5) * 0.1;
                bullets.push({ x: player.x, y: player.y, angle: angle, size: 5, hits: 0, life: 60 });
            }
        }

        function gainXp(amt) {
            player.xp += amt;
            if (player.xp >= player.nextXp) { player.xp = 0; player.nextXp = Math.floor(player.nextXp * 1.3); player.level++; showUpgrades(); }
            updateUI();
        }

        function takeDamage(amt) {
            if (player.invulnTimer > 0) return;
            player.hp -= amt; player.invulnTimer = 30; updateUI();
            if (player.hp <= 0) triggerDeath();
        }

        function updateUI() {
            document.getElementById('score-text').innerText = "KILLS: " + player.score;
            document.getElementById('level-text').innerText = "LVL: " + player.level;
            document.getElementById('xp-bar-fill').style.width = (player.xp / player.nextXp * 100) + "%";
            document.getElementById('hp-bar-fill').style.width = Math.max(0, (player.hp / player.maxHp) * 100) + "%";
            document.getElementById('hp-text').innerText = Math.ceil(player.hp) + " / " + player.maxHp;
        }

        function showUpgrades() {
            isPaused = true;
            let menu = document.getElementById('upgrade-menu');
            let container = document.getElementById('cards');
            container.innerHTML = "";
            menu.style.display = 'flex';
            let available = upgradePool.filter(u => u.count < u.max);
            if (available.length === 0) available = [upgradePool.find(u => u.id === 'hull')];
            let opts = [...available].sort(() => 0.5 - Math.random()).slice(0, 3);
            opts.forEach(u => {
                let el = document.createElement('div'); el.className = 'card';
                el.innerHTML = `<div class='rarity'></div><h3>${u.name}</h3><p>${u.desc}</p>`;
                el.onclick = () => {
                    u.count++;
                    if (u.type === 'stat') { if (u.key === 'fireRate') player.fireRate *= u.val; else if (u.key === 'bulletCount') player.bulletCount += u.val; else player[u.key] *= u.val; }
                    else if (u.type === 'heal') { player.maxHp += 50; player.hp = Math.min(player.maxHp, player.maxHp + 50); }
                    else { if (u.key === 'orbital') player.orbitals++; }
                    menu.style.display = 'none'; isPaused = false; updateUI();
                };
                container.appendChild(el);
            });
        }
        
        function triggerDeath() {
            gameActive = false; isDying = true; deathTimer = 0;
            if(player.score > 0) saveScoreToCloud(playerUid, playerName, player.score);
        }

        function drawDeathAnim() {
            draw(); deathTimer++;
            if (deathTimer > 60) {
                isDying = false;
                document.getElementById('death-screen').style.display = 'flex';
                document.getElementById('final-stats').innerText = "KILLS: " + player.score + " | LVL: " + player.level;
            }
        }

        function draw() {
            let curBg = cosmetics.find(c => c.id === equipped.bg) || cosmetics[6];
            let curSkin = cosmetics.find(c => c.id === equipped.skin) || cosmetics[0];
            let curProj = cosmetics.find(c => c.id === equipped.proj) || cosmetics[10];

            // BG
            ctx.fillStyle = curBg.bg; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = curBg.grid; ctx.lineWidth = 2; ctx.beginPath();
            let gs = 100, ox = -camera.x % gs, oy = -camera.y % gs;
            for (let x = ox; x < canvas.width; x += gs) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
            for (let y = oy; y < canvas.height; y += gs) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
            ctx.stroke();

            function drawAt(x, y, fn) { let sx = x - camera.x, sy = y - camera.y; if (sx<-50||sx>canvas.width+50||sy<-50||sy>canvas.height+50) return; ctx.save(); ctx.translate(sx, sy); fn(); ctx.restore(); }
            
            trailParticles.forEach(p => drawAt(p.x, p.y, () => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.beginPath(); ctx.arc(0,0,p.size,0,Math.PI*2); ctx.fill(); }));
            gems.forEach(g => drawAt(g.x, g.y, () => { ctx.fillStyle = '#00ff00'; ctx.beginPath(); ctx.arc(0,0, 5, 0, Math.PI*2); ctx.fill(); }));
            
            enemies.forEach(e => drawAt(e.x, e.y, () => {
                ctx.fillStyle = e.color; ctx.fillRect(-e.size/2,-e.size/2,e.size,e.size);
            }));

            if (!isDying) {
                ctx.save(); ctx.translate(player.x - camera.x, player.y - camera.y);
                if (player.orbitals > 0) {
                    let t = Date.now() * 0.002;
                    for(let i=0; i<player.orbitals; i++) {
                        let a = t + (i * (Math.PI*2/player.orbitals));
                        ctx.beginPath(); ctx.arc(Math.cos(a)*80, Math.sin(a)*80, 8, 0, Math.PI*2); ctx.fillStyle = curSkin.color; ctx.fill();
                    }
                }
                ctx.fillStyle = (player.invulnTimer > 0 && Math.floor(Date.now()/50)%2===0) ? 'red' : curSkin.color; 
                ctx.fillRect(-10, -10, 20, 20);
                ctx.restore();
            }

            bullets.forEach(b => drawAt(b.x, b.y, () => { 
                ctx.fillStyle = curProj.color; 
                if (curProj.symbol) {
                    ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline='middle'; ctx.fillText(curProj.symbol, 0, 0);
                } else {
                    ctx.beginPath(); ctx.arc(0,0, 4, 0, Math.PI*2); ctx.fill(); 
                }
            }));

            particles.forEach(p => drawAt(p.x, p.y, () => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.fillRect(0,0, 4, 4); }));
            ctx.fillStyle = '#fff'; ctx.font = "bold 14px Arial";
            damageText.forEach(d => drawAt(d.x, d.y, () => ctx.fillText(d.val, 0, 0)));
        }

        window.startGame = startGame;
        window.openShop = openShop;
        window.closeShop = closeShop;
        window.showLeaderboard = showLeaderboard;
        window.hideLeaderboard = hideLeaderboard;
        window.updateName = updateName;
        window.restartGame = restartGame;

        requestAnimationFrame(loop);
    </script>
</body>
</html>
