<!DOCTYPE html>
<html>
<head>
    <title>NEON SWARM: TACTICAL UPDATE</title>
    <style>
        :root { --hud-color: #00ffff; --hud-shadow: #0088ff; }
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }
        
        /* UI OVERLAY */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #hud-top {
            position: absolute; top: 20px; width: 100%;
            display: flex; flex-direction: column; align-items: center; gap: 10px;
        }
        
        #coin-hud {
            position: absolute; top: 20px; right: 30px;
            color: #ffd700; font-size: 24px; font-weight: bold;
            text-shadow: 0 0 10px #aa8800; display: flex; align-items: center; gap: 10px;
        }
        #coin-anim {
            position: absolute; top: 50px; right: 30px;
            color: #ffd700; font-size: 20px; font-weight: bold;
            opacity: 0; transition: opacity 0.5s, transform 0.5s;
        }

        /* ABILITY HUD (New) */
        #ability-panel {
            position: absolute; bottom: 30px; right: 30px;
            display: flex; gap: 15px; align-items: flex-end;
        }
        .ability-slot {
            width: 50px; height: 50px; border: 2px solid #333; border-radius: 8px;
            background: rgba(0,0,0,0.6); position: relative; overflow: hidden;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; box-shadow: 0 0 10px rgba(0,0,0,0.5);
            transition: transform 0.1s;
        }
        .ability-slot.ready { border-color: #fff; box-shadow: 0 0 15px #fff; transform: scale(1.1); }
        .ability-fill {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 0%;
            background: rgba(255,255,255,0.3); z-index: 0; transition: height 0.1s linear;
        }
        .ability-icon { z-index: 1; text-shadow: 0 0 5px black; }

        .stat-text { color: white; font-size: 20px; font-weight: bold; text-shadow: 0 0 10px #fff; }

        /* BARS */
        #hp-bar-container {
            width: 400px; height: 30px; background: rgba(0,0,0,0.5);
            border: 2px solid #555; border-radius: 5px; overflow: hidden; position: relative;
        }
        #hp-bar-fill {
            width: 100%; height: 100%; background: linear-gradient(90deg, #ff0000, #ff4444);
            transition: width 0.1s; box-shadow: 0 0 15px #ff0000;
        }
        #hp-text {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            font-size: 16px; font-weight: bold; color: white; text-shadow: 1px 1px 0 #000;
        }
        #xp-bar-container { position: absolute; bottom: 0; left: 0; width: 100%; height: 20px; background: #222; }
        #xp-bar-fill {
            width: 0%; height: 100%; background: var(--hud-color);
            transition: width 0.2s; box-shadow: 0 0 20px var(--hud-shadow);
        }

        /* MENUS */
        .menu-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); pointer-events: auto;
            display: flex; align-items: center; justify-content: center; flex-direction: column;
            backdrop-filter: blur(5px); z-index: 10;
        }

        .name-input {
            background: transparent; border: none; border-bottom: 2px solid var(--hud-color);
            color: white; font-size: 30px; text-align: center; margin-bottom: 30px;
            outline: none; text-transform: uppercase; letter-spacing: 2px;
            font-family: inherit; width: 300px;
        }
        .name-input::placeholder { color: #444; }

        .scroll-box {
            background: #111; border: 2px solid #333; width: 700px; max-height: 500px; 
            padding: 20px; border-radius: 10px; overflow-y: auto;
            box-shadow: 0 0 30px rgba(0,255,255,0.1);
        }

        .shop-section-title { color: #888; width: 100%; border-bottom: 1px solid #333; margin: 15px 0 5px 0; font-size: 14px; font-weight:bold; letter-spacing:1px; }
        .shop-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 15px; border-bottom: 1px solid #222; color: white;
        }
        .shop-preview { width: 30px; height: 30px; border-radius: 50%; margin-right: 15px; border: 2px solid #fff; display:flex; align-items:center; justify-content:center; font-size:14px;}
        .shop-info { display: flex; align-items: center; }
        .buy-btn {
            background: #333; border: 1px solid #555; padding: 8px 20px; font-weight: bold; cursor: pointer;
            color: white; border-radius: 5px; transition: 0.2s; width: 120px;
        }
        .buy-btn.can-buy { background: #ffd700; color: black; border-color: #ffd700; }
        .buy-btn.equipped { background: var(--hud-color); color: black; border-color: var(--hud-color); cursor: default; }
        .buy-btn:hover:not(:disabled):not(.equipped) { transform: scale(1.05); }

        .lb-row { display: flex; justify-content: space-between; padding: 10px; border-bottom: 1px solid #333; color: #aaa; font-size: 18px; }
        .lb-row.top { color: #ffd700; font-weight: bold; }

        .card-container { display: flex; gap: 20px; margin-top: 30px; }
        .card {
            background: linear-gradient(135deg, #222, #111); 
            border: 2px solid #444; width: 220px; padding: 25px;
            color: white; text-align: center; cursor: pointer; transition: 0.2s;
            border-radius: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            position: relative; overflow: hidden;
        }
        .card:hover { transform: translateY(-15px) scale(1.05); border-color: var(--hud-color); box-shadow: 0 0 30px var(--hud-shadow); }
        .card h3 { margin: 0 0 10px 0; color: var(--hud-color); font-size: 20px; }
        .card p { font-size: 13px; color: #ccc; line-height: 1.4; }
        .limit-tag { font-size: 10px; color: #888; margin-top: 10px; display:block; text-transform:uppercase; }

        .btn {
            background: linear-gradient(90deg, var(--hud-color), #0088ff); 
            border: none; padding: 15px 40px; font-size: 20px; font-weight: bold; color: #000;
            cursor: pointer; margin-top: 20px; border-radius: 50px; transition: 0.2s;
            box-shadow: 0 0 20px var(--hud-color); text-transform: uppercase;
        }
        .btn:hover { transform: scale(1.1); box-shadow: 0 0 40px var(--hud-color); color: white; }
        .btn-sec { background: #333; color: white; box-shadow: none; font-size: 16px; padding: 10px 30px; margin-left: 10px; }
        .btn-gold { background: linear-gradient(90deg, #ffd700, #ffaa00); box-shadow: 0 0 20px #ffd700; margin-left: 10px; }
        
        h1 { margin: 0; font-family: sans-serif; letter-spacing: 5px; text-transform: uppercase; }
        .neon-title { font-size: 80px; color: white; text-shadow: 0 0 20px var(--hud-color), 0 0 40px #0088ff; margin-bottom: 20px; }

    </style>
</head>
<body>

    <div id="ui-layer" style="display:none;">
        <div id="hud-top">
            <div id="hp-bar-container">
                <div id="hp-bar-fill"></div>
                <div id="hp-text">100 / 100</div>
            </div>
            <div style="display:flex; gap: 20px;">
                <span id="score-text" class="stat-text">KILLS: 0</span>
                <span id="time-text" class="stat-text" style="color:#ffaa00">00:00</span>
                <span id="level-text" class="stat-text" style="color:var(--hud-color)">LVL: 1</span>
            </div>
        </div>
        <div id="coin-hud">ü™ô <span id="coin-count">0</span></div>
        <div id="coin-anim">+1 ü™ô</div>
        
        <div id="ability-panel">
            <div class="ability-slot" id="slot-laser" style="display:none; border-color:#00ffff">
                <div class="ability-fill" id="fill-laser" style="background:rgba(0,255,255,0.4)"></div>
                <div class="ability-icon">‚ö°</div>
            </div>
            <div class="ability-slot" id="slot-mine" style="display:none; border-color:#ff5500">
                <div class="ability-fill" id="fill-mine" style="background:rgba(255,85,0,0.4)"></div>
                <div class="ability-icon">üí£</div>
            </div>
        </div>

        <div id="xp-bar-container"><div id="xp-bar-fill"></div></div>
    </div>

    <div id="start-screen" class="menu-screen">
        <h1 class="neon-title">NEON SWARM</h1>
        <input type="text" id="player-name" class="name-input" placeholder="ENTER NAME" maxlength="12" oninput="updateName(this.value)">
        <div style="display:flex; gap: 10px;">
            <button class="btn" onclick="startGame()">START</button>
            <button class="btn btn-gold" onclick="openShop()">SHOP</button>
            <button class="btn btn-sec" onclick="showLeaderboard()">LEADERBOARD</button>
        </div>
    </div>

    <div id="shop-screen" class="menu-screen" style="display:none;">
        <h1 style="color:#ffd700; text-shadow:0 0 20px #ffd700;">UPGRADE STATION</h1>
        <p style="color:white; margin-bottom:20px;">COINS: <span id="shop-coins" style="color:#ffd700; font-weight:bold;">0</span></p>
        <div id="shop-content" class="scroll-box"></div>
        <button class="btn btn-sec" onclick="closeShop()">BACK</button>
    </div>

    <div id="leaderboard-screen" class="menu-screen" style="display:none;">
        <h1 style="color:white; margin-bottom:20px;">LOCAL RANKING</h1>
        <div id="leaderboard-content" class="scroll-box" style="width:400px; text-align:center;"></div>
        <button class="btn btn-sec" onclick="hideLeaderboard()">BACK</button>
    </div>

    <div id="upgrade-menu" class="menu-screen" style="display:none;">
        <h1 style="color:white; font-size: 40px; text-shadow:0 0 20px var(--hud-color);">CHOOSE UPGRADE</h1>
        <div class="card-container" id="cards"></div>
    </div>

    <div id="death-screen" class="menu-screen" style="display:none;">
        <h1 style="font-size: 100px; color: #ab0000; text-shadow: 0 0 30px red;">YOU DIED</h1>
        <h2 id="final-stats" style="color:white; margin: 20px 0;">KILLS: 0</h2>
        <div style="display:flex; gap: 10px;">
            <button class="btn" onclick="restartGame()">RETRY</button>
            <button class="btn btn-gold" onclick="openShop()">SHOP</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const root = document.documentElement;
    
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize);
    resize();

    // --- GAME DATA ---
    let gameActive = false;
    let isPaused = false;
    let isDying = false; 
    let deathTimer = 0;
    let frame = 0;
    let camera = { x: 0, y: 0 };
    let globalDifficulty = 1;
    
    // Persistent Data
    let totalCoins = 0;
    let playerName = "PILOT";
    let inventory = ['skin_default', 'bg_default', 'proj_orb', 'trail_none', 'ui_default', 'death_default']; 
    let equipped = {
        skin: 'skin_default',
        bg: 'bg_default',
        proj: 'proj_orb',
        trail: 'trail_none',
        ui: 'ui_default',
        death: 'death_default'
    };

    // Player Stats
    let player = {
        x: 0, y: 0, hp: 100, maxHp: 100, regenTimer: 0, invulnTimer: 0,
        speed: 5, size: 15, level: 1, xp: 0, nextXp: 50, score: 0,
        fireRate: 25, bulletDmg: 20, bulletSpeed: 12, bulletCount: 1, pierce: 0, pickupRange: 150,
        orbitals: 0, meteorLevel: 0, lastMeteor: 0, laserLevel: 0, lastLaser: 0, mineLevel: 0, lastMine: 0
    };

    let bullets = [], enemies = [], particles = [], gems = [], damageText = [], meteors = [], lasers = [], mines = [], trailParticles = [];
    const keys = {};
    window.addEventListener('keydown', e => { keys[e.key] = true; keys[e.code] = true; });
    window.addEventListener('keyup', e => { keys[e.key] = false; keys[e.code] = false; });

    // --- COSMETICS DB ---
    const cosmetics = [
        // SHIPS
        { id: 'skin_default', type: 'skin', name: 'NEON CYAN', color: '#00ffff', cost: 0 },
        { id: 'skin_red', type: 'skin', name: 'CRIMSON FURY', color: '#ff0000', cost: 20 },
        { id: 'skin_gold', type: 'skin', name: 'MIDAS TOUCH', color: '#ffd700', cost: 50 },
        { id: 'skin_void', type: 'skin', name: 'VOID WALKER', color: '#aa00ff', cost: 30 },
        
        // BACKGROUNDS
        { id: 'bg_default', type: 'bg', name: 'DEEP SPACE', bg: '#050505', grid: '#222', cost: 0 },
        { id: 'bg_matrix', type: 'bg', name: 'THE MATRIX', bg: '#001100', grid: '#004400', cost: 30 },
        { id: 'bg_retro', type: 'bg', name: 'RETRO WAVE', bg: '#110011', grid: '#440044', cost: 40 },

        // PROJECTILES
        { id: 'proj_orb', type: 'proj', name: 'PLASMA ORB', symbol: '', color: '#ffff00', cost: 0 },
        { id: 'proj_star', type: 'proj', name: 'STAR POWER', symbol: '‚òÖ', color: '#ffaa00', cost: 50 },
        { id: 'proj_note', type: 'proj', name: 'SOUND WAVES', symbol: '‚ô™', color: '#00ff88', cost: 40 },
        { id: 'proj_skull', type: 'proj', name: 'DEATH TOUCH', symbol: 'üíÄ', color: '#cccccc', cost: 60 },
        { id: 'proj_bin', type: 'proj', name: 'BINARY', symbol: '10', color: '#00ff00', cost: 40 },

        // TRAILS
        { id: 'trail_none', type: 'trail', name: 'NO TRAIL', color: 'transparent', cost: 0 },
        { id: 'trail_rain', type: 'trail', name: 'RAINBOW', color: 'rainbow', cost: 60 },
        { id: 'trail_smoke', type: 'trail', name: 'ENGINE SMOKE', color: '#555', cost: 30 },
        { id: 'trail_pixie', type: 'trail', name: 'PIXIE DUST', color: '#ffccff', cost: 50 },
        { id: 'trail_bub', type: 'trail', name: 'BUBBLES', color: '#0088ff', cost: 40 },

        // UI
        { id: 'ui_default', type: 'ui', name: 'DEFAULT CYAN', hud: '#00ffff', shadow: '#0088ff', cost: 0 },
        { id: 'ui_pink', type: 'ui', name: 'CYBER PUNK', hud: '#ff00ff', shadow: '#aa00aa', cost: 40 },
        { id: 'ui_gold', type: 'ui', name: 'LUXURY GOLD', hud: '#ffd700', shadow: '#aa7700', cost: 60 },
        { id: 'ui_white', type: 'ui', name: 'MINIMALIST', hud: '#ffffff', shadow: '#888888', cost: 30 },

        // DEATH
        { id: 'death_default', type: 'death', name: 'STANDARD', cost: 0 },
        { id: 'death_conf', type: 'death', name: 'CONFETTI', cost: 50 },
        { id: 'death_hole', type: 'death', name: 'BLACK HOLE', cost: 100 }
    ];

    // --- SAVE / LOAD SYSTEM ---
    function loadData() {
        let saved = localStorage.getItem('neon_swarm_data_v3');
        if (saved) {
            let data = JSON.parse(saved);
            totalCoins = data.coins || 0;
            playerName = data.name || "PILOT";
            inventory = data.inventory || inventory;
            if(data.equipped) equipped = { ...equipped, ...data.equipped };
        }
        applyTheme();
        document.getElementById('coin-count').innerText = totalCoins;
        document.getElementById('player-name').value = playerName;
    }

    function saveData() {
        let data = { coins: totalCoins, name: playerName, inventory: inventory, equipped: equipped };
        localStorage.setItem('neon_swarm_data_v3', JSON.stringify(data));
    }
    
    function updateName(val) { playerName = val.toUpperCase(); saveData(); }
    
    function applyTheme() {
        let ui = cosmetics.find(c => c.id === equipped.ui) || cosmetics.find(c => c.id === 'ui_default');
        root.style.setProperty('--hud-color', ui.hud);
        root.style.setProperty('--hud-shadow', ui.shadow);
        // Force update stat texts
        document.getElementById('level-text').style.color = ui.hud;
    }

    loadData();

    // --- SHOP LOGIC ---
    function openShop() {
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('death-screen').style.display = 'none';
        document.getElementById('shop-screen').style.display = 'flex';
        renderShop();
    }

    function closeShop() {
        document.getElementById('shop-screen').style.display = 'none';
        document.getElementById('start-screen').style.display = 'flex';
    }

    function renderShop() {
        document.getElementById('shop-coins').innerText = totalCoins;
        let content = document.getElementById('shop-content');
        content.innerHTML = '';
        
        let categories = [
            { id: 'skin', name: 'SHIP SKINS' },
            { id: 'bg', name: 'BACKGROUNDS' },
            { id: 'proj', name: 'PROJECTILES' },
            { id: 'trail', name: 'ENGINE TRAILS' },
            { id: 'ui', name: 'HUD THEMES' },
            { id: 'death', name: 'DEATH FX' }
        ];

        categories.forEach(cat => {
            let title = document.createElement('div'); 
            title.className='shop-section-title'; 
            title.innerText = cat.name; 
            content.appendChild(title);
            
            cosmetics.filter(c => c.type === cat.id).forEach(item => {
                let row = document.createElement('div');
                row.className = 'shop-row';
                let owned = inventory.includes(item.id);
                let isEquipped = equipped[cat.id] === item.id;
                
                let btnText = isEquipped ? "EQUIPPED" : (owned ? "EQUIP" : "BUY " + item.cost + "ü™ô");
                let btnClass = isEquipped ? "buy-btn equipped" : (owned ? "buy-btn" : (totalCoins >= item.cost ? "buy-btn can-buy" : "buy-btn"));
                
                // Preview Logic
                let prevStyle = "";
                let prevInner = "";
                if(cat.id === 'skin') prevStyle = `background:${item.color}`;
                else if(cat.id === 'bg') prevStyle = `background:${item.bg}; border-color:${item.grid}`;
                else if(cat.id === 'proj') { prevStyle = `background:#000; border-color:${item.color}`; prevInner = item.symbol || '‚óè'; }
                else if(cat.id === 'trail') prevStyle = `background:${item.color === 'rainbow' ? 'linear-gradient(45deg, red, blue)' : item.color}`;
                else if(cat.id === 'ui') prevStyle = `background:${item.hud}`;
                else if(cat.id === 'death') prevStyle = `background:#333; color:red; border-color:red`;

                row.innerHTML = `
                    <div class="shop-info">
                        <div class="shop-preview" style="${prevStyle}; color:${item.color}">${prevInner}</div>
                        <div><h3 style="margin:0; font-size:16px; color:#fff">${item.name}</h3></div>
                    </div>
                    <button class="${btnClass}" ${(!owned && totalCoins < item.cost) ? 'disabled' : ''}>${btnText}</button>
                `;
                row.querySelector('button').onclick = () => handleShopClick(item, cat.id);
                content.appendChild(row);
            });
        });
    }

    function handleShopClick(item, type) {
        if (inventory.includes(item.id)) {
            equipped[type] = item.id;
        } else {
            if (totalCoins >= item.cost) {
                totalCoins -= item.cost; inventory.push(item.id);
                equipped[type] = item.id;
            }
        }
        if(type === 'ui') applyTheme();
        saveData(); renderShop(); document.getElementById('coin-count').innerText = totalCoins;
    }

    // --- LEADERBOARD & ENGINE SETUP ---
    function getLeaderboardData() {
        let stored = localStorage.getItem('neon_swarm_lb_v2');
        return stored ? JSON.parse(stored) : [];
    }
    function saveScore(score) {
        let data = getLeaderboardData();
        data.push({ name: playerName || "UNKNOWN", score: score });
        data.sort((a,b) => b.score - a.score);
        localStorage.setItem('neon_swarm_lb_v2', JSON.stringify(data.slice(0, 50)));
    }
    function showLeaderboard() {
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('leaderboard-screen').style.display = 'flex';
        let data = getLeaderboardData();
        let content = document.getElementById('leaderboard-content');
        content.innerHTML = "";
        if (data.length === 0) { content.innerHTML = "<p style='color:#666; margin-top:50px;'>NO RECORDS YET.</p>"; return; }
        data.slice(0, 10).forEach((entry, i) => {
            content.innerHTML += `<div class="lb-row ${i===0?'top':''}"><span>#${i+1} ${entry.name}</span><span>${entry.score}</span></div>`;
        });
    }
    function hideLeaderboard() {
        document.getElementById('leaderboard-screen').style.display = 'none';
        document.getElementById('start-screen').style.display = 'flex';
    }

    let upgradePool = [];
    function resetUpgrades() {
        upgradePool = [
            { id: "fire", name: "RAPID FIRE", desc: "Fire Rate +15%", type: "stat", key: "fireRate", val: 0.85, max: 8, count: 0 },
            { id: "multi", name: "MULTISHOT", desc: "+1 Projectile", type: "stat", key: "bulletCount", val: 1, max: 6, count: 0 },
            { id: "dmg", name: "HIGH CALIBER", desc: "Damage +30%", type: "stat", key: "bulletDmg", val: 1.3, max: 10, count: 0 },
            { id: "speed", name: "THRUSTERS", desc: "Move Speed +10%", type: "stat", key: "speed", val: 1.10, max: 5, count: 0 },
            { id: "mag", name: "MAGNET FIELD", desc: "Pickup Range +40%", type: "stat", key: "pickupRange", val: 1.4, max: 5, count: 0 },
            { id: "orb", name: "PLASMA ORBITAL", desc: "Add spinning shield", type: "ability", key: "orbital", max: 5, count: 0 },
            { id: "met", name: "METEOR STRIKE", desc: "Faster Meteor Rain", type: "ability", key: "meteor", max: 5, count: 0 },
            { id: "laser", name: "ION LASER", desc: "Shoot massive beam (10s cd)", type: "ability", key: "laser", max: 4, count: 0 },
            { id: "mine", name: "PROXIMITY MINE", desc: "Drop bomb behind you", type: "ability", key: "mine", max: 5, count: 0 },
            { id: "hull", name: "TITANIUM HULL", desc: "+50 Max HP & Heal", type: "heal", max: 99, count: 0 }
        ];
    }

    function startGame() {
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('ui-layer').style.display = 'block';
        restartGame();
    }

    function restartGame() {
        gameActive = true; isPaused = false; isDying = false; frame = 0; globalDifficulty = 1;
        player = {
            x: 0, y: 0, hp: 100, maxHp: 100, regenTimer: 0, invulnTimer: 0,
            speed: 5, size: 15, level: 1, xp: 0, nextXp: 50, score: 0,
            fireRate: 25, bulletDmg: 20, bulletSpeed: 12, bulletCount: 1, pierce: 0, pickupRange: 150,
            orbitals: 0, meteorLevel: 0, lastMeteor: 0, laserLevel: 0, lastLaser: 0, mineLevel: 0, lastMine: 0
        };
        resetUpgrades();
        bullets = []; enemies = []; particles = []; gems = []; damageText = []; meteors = []; lasers = []; mines = []; trailParticles = [];
        document.getElementById('death-screen').style.display = 'none';
        document.getElementById('upgrade-menu').style.display = 'none';
        updateUI();
    }

    function loop() {
        if (gameActive && !isPaused) { update(); draw(); frame++; }
        else if (isDying) { drawDeathAnim(); }
        requestAnimationFrame(loop);
    }

    function update() {
        globalDifficulty = 1 + (frame / 2000); 
        camera.x = player.x - canvas.width / 2;
        camera.y = player.y - canvas.height / 2;

        // WASD
        let dx = 0, dy = 0;
        if (keys['KeyW'] || keys['ArrowUp']) dy = -1;
        if (keys['KeyS'] || keys['ArrowDown']) dy = 1;
        if (keys['KeyA'] || keys['ArrowLeft']) dx = -1;
        if (keys['KeyD'] || keys['ArrowRight']) dx = 1;
        
        let moving = (dx !== 0 || dy !== 0);
        if (moving) {
            let len = Math.hypot(dx, dy);
            player.x += (dx/len) * player.speed;
            player.y += (dy/len) * player.speed;
        }

        // TRAIL GENERATION
        if (moving && frame % 5 === 0 && equipped.trail !== 'trail_none') {
            let tColor = '#fff';
            let tSize = 4;
            let tLife = 1;
            let trailDef = cosmetics.find(c => c.id === equipped.trail);
            
            if (equipped.trail === 'trail_rain') tColor = `hsl(${frame%360}, 100%, 50%)`;
            else if (equipped.trail === 'trail_smoke') { tColor = 'rgba(100,100,100,0.5)'; tSize = 8; tLife = 1.5; }
            else if (equipped.trail === 'trail_pixie') { tColor = '#fff'; tSize = 2; }
            else if (equipped.trail === 'trail_bub') { tColor = 'rgba(0, 100, 255, 0.4)'; tSize = 6; }
            
            trailParticles.push({ x: player.x, y: player.y, color: tColor, size: tSize, life: tLife, type: equipped.trail });
        }

        player.regenTimer++;
        if (player.regenTimer >= 60 && player.hp < player.maxHp) {
            player.hp = Math.min(player.maxHp, player.hp + 1); player.regenTimer = 0; updateUI();
        }
        if (player.invulnTimer > 0) player.invulnTimer--;

        if (frame % Math.floor(player.fireRate) === 0) shoot();
        if (player.laserLevel > 0 && frame - player.lastLaser > 600) { fireLaser(); player.lastLaser = frame; }
        if (player.mineLevel > 0) {
            let mineCd = Math.max(90, 300 - (player.mineLevel * 40)); 
            if (frame - player.lastMine > mineCd) { dropMine(); player.lastMine = frame; }
        }
        if (player.meteorLevel > 0) {
            let delay = 5000 / player.meteorLevel; 
            if (Date.now() - player.lastMeteor > delay) { triggerMeteor(); player.lastMeteor = Date.now(); }
        }

        updateEntities();
        
        let seconds = Math.floor(frame / 60);
        let mins = Math.floor(seconds / 60);
        let secs = seconds % 60;
        document.getElementById('time-text').innerText = (mins<10?"0":"")+mins + ":" + (secs<10?"0":"")+secs;
        updateUI(); // Keep cooldowns smooth
    }

    function updateEntities() {
        // Trail Updates
        for(let i=trailParticles.length-1; i>=0; i--) {
            let p = trailParticles[i]; p.life -= 0.02; 
            if (p.type === 'trail_smoke') { p.y -= 1; p.size += 0.2; }
            if (p.type === 'trail_bub') { p.x += Math.sin(frame/10 + i)*0.5; p.y += Math.cos(frame/10)*0.5; }
            if(p.life <= 0) trailParticles.splice(i, 1);
        }

        for(let i=lasers.length-1; i>=0; i--) {
            let l = lasers[i]; l.life -= 0.05;
            if(l.life > 0.8) {
                enemies.forEach(e => {
                    let vx = e.x - l.x, vy = e.y - l.y;
                    let rx = vx * Math.cos(-l.angle) - vy * Math.sin(-l.angle);
                    let ry = vx * Math.sin(-l.angle) + vy * Math.cos(-l.angle);
                    if (Math.abs(ry) < e.size + l.width && rx > 0) damageEnemy(e, 30); 
                });
            }
            if(l.life <= 0) lasers.splice(i, 1);
        }

        for(let i=mines.length-1; i>=0; i--) {
            let m = mines[i]; m.timer--;
            if (m.timer <= 0) {
                spawnParticles(m.x, m.y, '#ffaa00', 20);
                enemies.forEach(e => { if (Math.hypot(m.x-e.x, m.y-e.y) < 250) damageEnemy(e, m.dmg); });
                mines.splice(i, 1);
            }
        }

        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i];
            b.x += Math.cos(b.angle) * player.bulletSpeed;
            b.y += Math.sin(b.angle) * player.bulletSpeed;
            b.life--;
            let hit = false;
            for (let e of enemies) {
                if (Math.hypot(b.x - e.x, b.y - e.y) < e.size + b.size) {
                    damageEnemy(e, player.bulletDmg);
                    spawnParticles(b.x, b.y, cosmetics.find(c=>c.id===equipped.proj).color, 3);
                    b.hits++; if (b.hits > player.pierce) hit = true; break; 
                }
            }
            if (hit || b.life <= 0) bullets.splice(i, 1);
        }

        let spawnRate = Math.max(1, 40 - (player.level*1.5 + (frame/600))); 
        if (frame % Math.floor(spawnRate) === 0) spawnEnemy();
        if (frame > 0 && frame % 1800 === 0) spawnBoss();

        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            let angle = Math.atan2(player.y - e.y, player.x - e.x);
            e.x += Math.cos(angle) * e.speed;
            e.y += Math.sin(angle) * e.speed;

            if (e.type === 'dasher') {
                if (!e.dashMode) { if (Math.random() < 0.01) { e.dashMode = true; e.dashTimer = 30; } }
                else {
                    e.dashTimer--;
                    if (e.dashTimer <= 0) {
                         e.x += Math.cos(angle) * 12; e.y += Math.sin(angle) * 12;
                         if (Math.random() < 0.1) e.dashMode = false;
                    }
                }
            }
            if (player.orbitals > 0) {
                let dist = Math.hypot(player.x - e.x, player.y - e.y);
                if (dist < 100 && frame % 10 === 0) { 
                     damageEnemy(e, player.bulletDmg * 0.8); spawnParticles(e.x, e.y, '#00ffff', 2);
                }
            }
            let dist = Math.hypot(player.x - e.x, player.y - e.y);
            if (dist < player.size + e.size) { takeDamage(e.type === 'titan' ? 40 : 10); }
            if (dist > 2500) enemies.splice(i, 1);
        }

        for (let i = meteors.length - 1; i >= 0; i--) {
            let m = meteors[i]; m.timer--;
            if (m.timer <= 0) {
                spawnParticles(m.x, m.y, '#ff5500', 30);
                enemies.forEach(e => { if (Math.hypot(m.x - e.x, m.y - e.y) < m.radius) damageEnemy(e, player.bulletDmg * 10); });
                meteors.splice(i, 1);
            }
        }

        for (let i = gems.length - 1; i >= 0; i--) {
            let g = gems[i];
            let dist = Math.hypot(player.x - g.x, player.y - g.y);
            if (dist < player.pickupRange) g.mag = true;
            if (g.mag) {
                let angle = Math.atan2(player.y - g.y, player.x - g.x);
                let speed = player.speed + 8; 
                g.x += Math.cos(angle) * speed;
                g.y += Math.sin(angle) * speed;
                if (dist < player.size + 10) { gainXp(g.val); gems.splice(i, 1); }
            }
        }
        particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life -= 0.05; if(p.life <= 0) particles.splice(i,1); });
        damageText.forEach((d, i) => { d.y -= 1; d.life -= 0.02; if(d.life <= 0) damageText.splice(i,1); });
    }

    function spawnBoss() {
        let angle = Math.random() * Math.PI * 2;
        let x = player.x + Math.cos(angle) * 600;
        let y = player.y + Math.sin(angle) * 600;
        let bossHp = 300 * globalDifficulty;
        enemies.push({ x, y, type: 'titan', size: 60, hp: bossHp, maxHp: bossHp, speed: 1.8 + (globalDifficulty * 0.2), color: '#aa00ff' });
        camera.x += (Math.random()-0.5)*50;
    }

    function spawnEnemy() {
        let angle = Math.random() * Math.PI * 2;
        let dist = (Math.max(canvas.width, canvas.height) / 2) + 100;
        let x = player.x + Math.cos(angle) * dist;
        let y = player.y + Math.sin(angle) * dist;
        let type = 'grunt', size = 20, hp = 20 * globalDifficulty, speed = 2 + (globalDifficulty*0.2), color = '#ff0055';
        if (player.score > 50 && Math.random() > 0.85) { type = 'dasher'; color = '#ff8800'; speed = 1.5 + (globalDifficulty*0.2); hp = 50 * globalDifficulty; size=25; }
        enemies.push({ x, y, type, size, hp, speed, color, dashMode: false });
    }

    function damageEnemy(e, amt) {
        e.hp -= amt;
        damageText.push({ x: e.x, y: e.y, val: Math.floor(amt), life: 1 });
        if (e.hp <= 0 && enemies.includes(e)) {
            enemies.splice(enemies.indexOf(e), 1);
            player.score++;
            if (player.score % 10 === 0) {
                totalCoins++; saveData(); document.getElementById('coin-count').innerText = totalCoins;
                let anim = document.getElementById('coin-anim'); anim.style.opacity = '1'; anim.style.transform = 'translateY(-20px)';
                setTimeout(() => { anim.style.opacity = '0'; anim.style.transform = 'translateY(0)'; }, 800);
            }
            if (e.type === 'titan') {
                for(let k=0; k<5; k++) gems.push({ x: e.x + (Math.random()-0.5)*50, y: e.y + (Math.random()-0.5)*50, val: 150, mag: false });
            } else {
                gems.push({ x: e.x, y: e.y, val: 5 + Math.floor(globalDifficulty), mag: false });
            }
            updateUI();
        }
    }

    // --- SMART TARGETING ---
    function shoot() {
        let targets = getNearestEnemies(player.x, player.y, 650);
        if (targets.length === 0) return;
        for (let i = 0; i < player.bulletCount; i++) {
            let target = targets[i % targets.length];
            let angle = Math.atan2(target.y - player.y, target.x - player.x);
            angle += (Math.random() - 0.5) * 0.1;
            bullets.push({ x: player.x, y: player.y, angle: angle, size: 5, hits: 0, life: 60 });
        }
    }
    function getNearestEnemies(x, y, range) {
        let list = enemies.map(e => ({ e: e, dist: Math.hypot(x - e.x, y - e.y) }));
        list = list.filter(item => item.dist < range).sort((a, b) => a.dist - b.dist);
        return list.map(item => item.e);
    }
    function getNearestEnemy(x, y, range) {
        let nearest = null; let minDst = range;
        enemies.forEach(e => { let d = Math.hypot(x-e.x, y-e.y); if(d < minDst) { minDst = d; nearest = e; } });
        return nearest;
    }
    function fireLaser() {
        let t = getNearestEnemy(player.x, player.y, 2000);
        let baseAngle = t ? Math.atan2(t.y - player.y, t.x - player.x) : Math.random() * Math.PI * 2;
        let count = player.laserLevel;
        let angles = count === 1 ? [0] : count === 2 ? [0, Math.PI] : count === 3 ? [0, 2.09, 4.18] : [0, Math.PI/2, Math.PI, -Math.PI/2];
        angles.forEach(a => lasers.push({ x: player.x, y: player.y, angle: baseAngle + a, life: 1.0, width: 40 }));
    }
    function dropMine() { mines.push({ x: player.x, y: player.y, timer: 150, dmg: player.bulletDmg * 8 }); }
    function triggerMeteor() {
        let tx, ty;
        if (enemies.length > 0) { let e = enemies[Math.floor(Math.random() * enemies.length)]; tx = e.x; ty = e.y; }
        else { let a = Math.random()*Math.PI*2, d = 100+Math.random()*200; tx = player.x+Math.cos(a)*d; ty = player.y+Math.sin(a)*d; }
        meteors.push({ x: tx, y: ty, radius: 120 + (player.meteorLevel * 10), timer: 45 });
    }
    function gainXp(amt) {
        player.xp += amt;
        if (player.xp >= player.nextXp) { player.xp = 0; player.nextXp = Math.floor(player.nextXp * 1.3); player.level++; showUpgrades(); }
        updateUI();
    }
    function takeDamage(amt) {
        if (player.invulnTimer > 0) return;
        player.hp -= amt; player.invulnTimer = 30; updateUI();
        if (player.hp <= 0) triggerDeath();
    }
    function updateUI() {
        document.getElementById('score-text').innerText = "KILLS: " + player.score;
        document.getElementById('level-text').innerText = "LVL: " + player.level;
        document.getElementById('xp-bar-fill').style.width = (player.xp / player.nextXp * 100) + "%";
        document.getElementById('hp-bar-fill').style.width = Math.max(0, (player.hp / player.maxHp) * 100) + "%";
        document.getElementById('hp-text').innerText = Math.ceil(player.hp) + " / " + player.maxHp;

        // Ability HUD Updates
        if(player.laserLevel > 0) {
            let slot = document.getElementById('slot-laser'); slot.style.display = 'flex';
            let pct = Math.min(1, (frame - player.lastLaser) / 600);
            document.getElementById('fill-laser').style.height = (pct*100) + "%";
            slot.classList.toggle('ready', pct >= 1);
        }
        if(player.mineLevel > 0) {
            let slot = document.getElementById('slot-mine'); slot.style.display = 'flex';
            let cd = Math.max(90, 300 - (player.mineLevel * 40));
            let pct = Math.min(1, (frame - player.lastMine) / cd);
            document.getElementById('fill-mine').style.height = (pct*100) + "%";
            slot.classList.toggle('ready', pct >= 1);
        }
    }
    function showUpgrades() {
        isPaused = true;
        let menu = document.getElementById('upgrade-menu');
        let container = document.getElementById('cards');
        container.innerHTML = "";
        menu.style.display = 'flex';
        let available = upgradePool.filter(u => u.count < u.max);
        if (available.length === 0) available = [upgradePool.find(u => u.id === 'hull')];
        let opts = [...available].sort(() => 0.5 - Math.random()).slice(0, 3);
        opts.forEach(u => {
            let el = document.createElement('div'); el.className = 'card';
            el.innerHTML = `<div class='rarity'></div><h3>${u.name}</h3><p>${u.desc}</p><span class='limit-tag'>OWNED: ${u.count} / ${u.max >= 99 ? '‚àû' : u.max}</span>`;
            el.onclick = () => {
                u.count++;
                if (u.type === 'stat') { if (u.key === 'fireRate') player.fireRate *= u.val; else if (u.key === 'bulletCount') player.bulletCount += u.val; else player[u.key] *= u.val; }
                else if (u.type === 'heal') { player.maxHp += 50; player.hp = Math.min(player.maxHp, player.hp + 50); }
                else { if (u.key === 'orbital') player.orbitals++; if (u.key === 'meteor') { player.meteorLevel++; player.lastMeteor = 0; } if (u.key === 'laser') { player.laserLevel++; player.lastLaser = 0; } if (u.key === 'mine') { player.mineLevel++; player.lastMine = 0; } }
                menu.style.display = 'none'; isPaused = false; updateUI();
            };
            container.appendChild(el);
        });
    }
    function spawnParticles(x, y, color, count) { for(let i=0; i<count; i++) particles.push({ x, y, color, vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5, life: 1 }); }
    
    // --- DEATH EFFECTS ---
    function triggerDeath() {
        gameActive = false;
        isDying = true;
        deathTimer = 0;
        
        if (equipped.death === 'death_conf') {
            for(let i=0; i<100; i++) {
                particles.push({ 
                    x: player.x, y: player.y, 
                    color: `hsl(${Math.random()*360}, 100%, 50%)`, 
                    vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15, life: 2.0 
                });
            }
        }
    }

    function drawDeathAnim() {
        draw(); // Keep drawing game frozen in background
        deathTimer++;
        ctx.save();
        ctx.translate(player.x - camera.x, player.y - camera.y);
        
        if (equipped.death === 'death_hole') {
            let size = deathTimer * 20;
            ctx.fillStyle = 'black';
            ctx.beginPath(); ctx.arc(0,0,size,0,Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
        } 

        ctx.restore();
        
        if (deathTimer > 60) showDeathScreen();
    }

    function showDeathScreen() {
        isDying = false;
        saveScore(player.score);
        document.getElementById('death-screen').style.display = 'flex';
        document.getElementById('final-stats').innerText = "KILLS: " + player.score + " | LVL: " + player.level;
    }

    // --- TELEGRAPHING ---
    function drawTelegraphs(sx, sy) {
        // Laser Telegraph
        if (player.laserLevel > 0) {
            let passed = frame - player.lastLaser;
            if (passed > 500) { // 1.5 seconds before firing
                let t = getNearestEnemy(player.x, player.y, 2000);
                let angle = t ? Math.atan2(t.y - player.y, t.x - player.x) : 0;
                let opacity = (passed - 500) / 100;
                ctx.save(); ctx.translate(sx, sy); ctx.rotate(angle);
                ctx.fillStyle = `rgba(0, 255, 255, ${opacity * 0.3})`;
                ctx.fillRect(0, -1, 2000, 2); // Thin line
                ctx.restore();
            }
        }
        // Mine Telegraph
        if (player.mineLevel > 0) {
            let cd = Math.max(90, 300 - (player.mineLevel * 40));
            let passed = frame - player.lastMine;
            if (passed > cd - 60) { // 1 sec before
                let alpha = (Math.sin(frame/5) + 1) / 2;
                ctx.save(); ctx.translate(sx, sy);
                ctx.strokeStyle = `rgba(255, 50, 0, ${alpha})`;
                ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.stroke();
                ctx.restore();
            }
        }
    }
    
    function draw() {
        let curBg = cosmetics.find(c => c.id === equipped.bg) || cosmetics[5];
        let curSkin = cosmetics.find(c => c.id === equipped.skin) || cosmetics[0];
        let curProj = cosmetics.find(c => c.id === equipped.proj) || cosmetics[9];

        // Background
        ctx.fillStyle = curBg.bg; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = curBg.grid; ctx.lineWidth = 2; ctx.beginPath();
        let gs = 100, ox = -camera.x % gs, oy = -camera.y % gs;
        for (let x = ox; x < canvas.width; x += gs) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
        for (let y = oy; y < canvas.height; y += gs) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
        ctx.stroke();

        function drawAt(x, y, fn) { let sx = x - camera.x, sy = y - camera.y; if (sx<-2000||sx>canvas.width+2000||sy<-2000||sy>canvas.height+2000) return; ctx.save(); ctx.translate(sx, sy); fn(); ctx.restore(); }
        
        // Draw Telegraphs UNDER entities
        if (!isDying) drawTelegraphs(player.x - camera.x, player.y - camera.y);

        trailParticles.forEach(p => drawAt(p.x, p.y, () => {
             ctx.fillStyle = p.color; ctx.globalAlpha = p.life; 
             if(p.type === 'trail_pixie') { ctx.translate(Math.random()*2, Math.random()*2); ctx.fillRect(0,0,p.size,p.size); }
             else if (p.type === 'trail_bub') { ctx.strokeStyle = p.color; ctx.beginPath(); ctx.arc(0,0,p.size,0,Math.PI*2); ctx.stroke(); }
             else { ctx.beginPath(); ctx.arc(0,0,p.size,0,Math.PI*2); ctx.fill(); }
        }));

        mines.forEach(m => drawAt(m.x, m.y, () => {
            let f = Math.floor(Date.now()/100)%2===0; ctx.fillStyle=f?'#ff0000':'#440000'; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
            ctx.strokeStyle = 'rgba(255,0,0,0.2)'; ctx.beginPath(); ctx.arc(0,0,250*(1-(m.timer/150)),0,Math.PI*2); ctx.stroke();
        }));
        gems.forEach(g => drawAt(g.x, g.y, () => { ctx.fillStyle = '#00ff00'; ctx.beginPath(); ctx.arc(0,0, 5, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur=10;ctx.shadowColor='#00ff00';ctx.fill(); }));
        lasers.forEach(l => drawAt(l.x, l.y, () => { ctx.rotate(l.angle); ctx.fillStyle=`rgba(0,255,255,${l.life})`; ctx.fillRect(0,-l.width/2,2000,l.width); ctx.fillStyle=`rgba(255,255,255,${l.life})`; ctx.fillRect(0,-l.width/4,2000,l.width/2); }));
        meteors.forEach(m => drawAt(m.x, m.y, () => { ctx.strokeStyle = `rgba(255,50,0,${0.5+Math.random()*0.5})`; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(0,0,m.radius,0,Math.PI*2); ctx.stroke(); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,-m.timer*8,15,0,Math.PI*2); ctx.fill(); }));
        
        enemies.forEach(e => drawAt(e.x, e.y, () => {
            ctx.fillStyle = e.color;
            if (e.type === 'titan') {
                ctx.shadowBlur=20; ctx.shadowColor='#aa00ff'; ctx.fillRect(-e.size/2,-e.size/2,e.size,e.size); ctx.shadowBlur=0;
                ctx.fillStyle='red'; ctx.fillRect(-30,-e.size,60,5); ctx.fillStyle='#0f0'; ctx.fillRect(-30,-e.size,60*(e.hp/e.maxHp),5);
            } else if (e.type==='dasher') { ctx.beginPath();ctx.arc(0,0,e.size/2,0,Math.PI*2);ctx.fill();ctx.strokeStyle='white';ctx.stroke(); }
            else ctx.fillRect(-e.size/2,-e.size/2,e.size,e.size);
        }));

        if (!isDying) {
            ctx.save(); ctx.translate(player.x - camera.x, player.y - camera.y);
            if (player.orbitals > 0) {
                let t = Date.now() * 0.002;
                for(let i=0; i<player.orbitals; i++) {
                    let a = t + (i * (Math.PI*2/player.orbitals));
                    ctx.beginPath(); ctx.arc(Math.cos(a)*80, Math.sin(a)*80, 8, 0, Math.PI*2); ctx.fillStyle = curSkin.color; ctx.fill(); ctx.shadowBlur=15;ctx.shadowColor=curSkin.color;ctx.fill();ctx.shadowBlur=0;
                }
            }
            ctx.fillStyle = (player.invulnTimer > 0 && Math.floor(Date.now()/50)%2===0) ? 'red' : curSkin.color; 
            ctx.fillRect(-10, -10, 20, 20);
            ctx.shadowBlur = 10; ctx.shadowColor = curSkin.color; ctx.strokeRect(-10,-10,20,20);
            ctx.restore();
        }

        bullets.forEach(b => drawAt(b.x, b.y, () => { 
            ctx.fillStyle = curProj.color; 
            if (curProj.symbol) {
                ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline='middle';
                if(curProj.id==='proj_bin') ctx.fillText(Math.random()>0.5?'1':'0', 0, 0);
                else ctx.fillText(curProj.symbol, 0, 0);
            } else {
                ctx.beginPath(); ctx.arc(0,0, 4, 0, Math.PI*2); ctx.fill(); 
            }
        }));

        particles.forEach(p => drawAt(p.x, p.y, () => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.fillRect(0,0, 4, 4); }));
        ctx.fillStyle = '#fff'; ctx.font = "bold 14px Arial";
        damageText.forEach(d => drawAt(d.x, d.y, () => ctx.fillText(d.val, 0, 0)));
    }

    requestAnimationFrame(loop);
</script>
</body>
</html>
